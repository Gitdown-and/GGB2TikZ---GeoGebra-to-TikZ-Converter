<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GGB to TikZ Converter</title>
    <meta name="description" content="Convert GeoGebra (.ggb) files to TikZ code for LaTeX">
    <style>
        :root {
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f0f7ff;
            --text-primary: #333333;
            --text-secondary: #555555;
            --text-muted: #888888;
            --border-color: #dddddd;
            --border-light: #ecf0f1;
            --accent-color: #3498db;
            --accent-hover: #2980b9;
            --shadow-color: rgba(0,0,0,0.1);
            --dropzone-bg: #f0f7ff;
            --dropzone-hover: #e3f2fd;
            --options-bg: #f8f9fa;
            --range-bg: #fff3e0;
            --range-border: #ffcc80;
            --info-bg: #f0f7ff;
            --info-border: #b8daff;
            --file-bg: #e8f5e9;
            --file-text: #2e7d32;
            --notification-success: #2ecc71;
            --notification-error: #e74c3c;
        }
        
        [data-theme="dark"] {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #1f2940;
            --text-primary: #e8e8e8;
            --text-secondary: #b8b8b8;
            --text-muted: #888888;
            --border-color: #3a3a5a;
            --border-light: #2a2a4a;
            --accent-color: #4aa3df;
            --accent-hover: #5bb5f0;
            --shadow-color: rgba(0,0,0,0.3);
            --dropzone-bg: #1f2940;
            --dropzone-hover: #252f45;
            --options-bg: #1f2940;
            --range-bg: #2a2a3a;
            --range-border: #4a4a6a;
            --info-bg: #1f2940;
            --info-border: #3a5a7a;
            --file-bg: #1a3a2a;
            --file-text: #4caf50;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 20px;
            transition: background 0.3s, color 0.3s;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .input-section, .output-section {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 4px var(--shadow-color);
            transition: background 0.3s;
        }
        
        h2 {
            color: var(--text-primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-light);
            font-size: 18px;
            font-weight: 600;
        }
        
        .drop-zone {
            border: 3px dashed var(--accent-color);
            border-radius: 10px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--dropzone-bg);
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--accent-hover);
            background: var(--dropzone-hover);
        }
        
        .drop-zone-icon {
            font-size: 48px;
            color: var(--accent-color);
            margin-bottom: 15px;
        }
        
        .drop-zone-text {
            font-size: 16px;
            color: var(--text-secondary);
        }
        
        .drop-zone-hint {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 10px;
        }
        
        #fileInput {
            display: none;
        }
        
        textarea {
            width: 100%;
            height: 400px;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            resize: vertical;
            transition: border-color 0.3s, background 0.3s, color 0.3s;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--accent-color);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 20px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        button:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px var(--shadow-color);
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }
        
        #copyBtn {
            background: #9b59b6;
        }
        
        #copyBtn:hover {
            background: #8e44ad;
        }
        
        #clearBtn {
            background: #e74c3c;
        }
        
        #clearBtn:hover {
            background: #c0392b;
        }
        
        .options {
            margin-top: 15px;
            padding: 15px;
            background: var(--options-bg);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .options label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
        }
        
        .options input {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .range-settings {
            margin-top: 15px;
            padding: 15px;
            background: var(--range-bg);
            border-radius: 6px;
            border: 1px solid var(--range-border);
        }
        
        .range-settings h4 {
            color: var(--accent-color);
            margin-bottom: 12px;
            font-size: 14px;
        }
        
        .range-settings > label {
            display: block;
            margin-bottom: 10px;
            color: var(--text-primary);
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
        }
        
        .range-settings > label input {
            margin-right: 8px;
        }
        
        .range-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 8px;
        }
        
        .range-row label {
            min-width: 60px;
            font-weight: 500;
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .range-row input[type="number"] {
            width: 70px;
            padding: 5px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 13px;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .range-row .separator {
            color: var(--text-muted);
            font-size: 13px;
        }
        
        .range-hint {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 8px;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background: var(--notification-success);
            color: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px var(--shadow-color);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s;
            z-index: 1000;
            font-size: 14px;
            font-weight: 500;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .notification.error {
            background: var(--notification-error);
        }
        
        .element-info {
            margin-top: 15px;
            padding: 15px;
            background: var(--info-bg);
            border-radius: 6px;
            border: 1px solid var(--info-border);
            font-size: 13px;
        }
        
        .element-info h4 {
            color: var(--text-primary);
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .element-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .element-tag {
            display: inline-block;
            padding: 3px 8px;
            background: var(--accent-color);
            color: white;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .info-links {
            margin-top: 15px;
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .info-links a {
            color: var(--accent-color);
            text-decoration: none;
        }
        
        .info-links a:hover {
            text-decoration: underline;
        }
        
        .file-name {
            margin-top: 10px;
            padding: 8px 12px;
            background: var(--file-bg);
            border-radius: 4px;
            font-size: 13px;
            color: var(--file-text);
        }
        
        /* Theme toggle styles */
        .theme-toggle {
            margin-top: 20px;
            padding: 15px;
            background: var(--options-bg);
            border-radius: 6px;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .theme-toggle-label {
            color: var(--text-primary);
            font-weight: 500;
            font-size: 14px;
        }
        
        .theme-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }
        
        .theme-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .theme-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 26px;
        }
        
        .theme-slider:before {
            position: absolute;
            content: "‚òÄÔ∏è";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .theme-switch input:checked + .theme-slider {
            background-color: var(--accent-color);
        }
        
        .theme-switch input:checked + .theme-slider:before {
            transform: translateX(24px);
            content: "üåô";
        }
        
        /* GitHub link styles */
        .github-link {
            margin-top: 15px;
            padding: 12px 15px;
            background: var(--options-bg);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .github-link a {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-primary);
            text-decoration: none;
            font-size: 14px;
            transition: color 0.2s;
        }
        
        .github-link a:hover {
            color: var(--accent-color);
        }
        
        .github-link svg {
            flex-shrink: 0;
        }
        
        /* Function settings panel */
        .function-settings {
            margin-top: 15px;
            padding: 15px;
            background: var(--range-bg);
            border-radius: 6px;
            border: 1px solid var(--range-border);
            display: none;
        }
        
        .function-settings.active {
            display: block;
        }
        
        .function-settings h4 {
            color: var(--accent-color);
            margin-bottom: 12px;
            font-size: 14px;
        }
        
        .function-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .function-item:last-child {
            margin-bottom: 0;
        }
        
        .function-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .function-expr {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            padding: 4px 8px;
            border-radius: 4px;
            flex: 1;
            min-width: 150px;
        }
        
        .function-color-preview {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .function-style-tag {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            background: var(--accent-color);
            color: white;
            flex-shrink: 0;
        }
        
        .function-style-tag.dashed {
            background: #e67e22;
        }
        
        .function-range-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        
        .function-range-row label {
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        
        .function-range-row input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            min-width: 120px;
        }
        
        .function-range-row input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-color);
        }
        
        .function-range-hint {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 6px;
        }
        
        .no-functions {
            color: var(--text-muted);
            font-size: 13px;
            text-align: center;
            padding: 10px;
        }
        
        /* Language selector styles */
        .lang-selector {
            position: fixed;
            top: 15px;
            right: 20px;
            z-index: 1100;
        }
        
        .lang-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-primary);
            transition: all 0.2s;
            box-shadow: 0 2px 6px var(--shadow-color);
        }
        
        .lang-btn:hover {
            border-color: var(--accent-color);
            transform: translateY(-1px);
        }
        
        .lang-btn .globe-icon {
            font-size: 16px;
        }
        
        /* Language modal styles */
        .lang-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1200;
        }
        
        .lang-modal-overlay.active {
            display: flex;
        }
        
        .lang-modal {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 0;
            min-width: 320px;
            max-width: 90%;
            box-shadow: 0 10px 40px var(--shadow-color);
            animation: modalSlideIn 0.2s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        
        .lang-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .lang-modal-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .lang-modal-close {
            width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 20px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
            padding: 0;
        }
        
        .lang-modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .lang-modal-body {
            padding: 16px 20px;
        }
        
        .lang-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 10px;
        }
        
        .lang-option:last-child {
            margin-bottom: 0;
        }
        
        .lang-option:hover {
            border-color: var(--accent-color);
            background: var(--bg-tertiary);
        }
        
        .lang-option.selected {
            border-color: var(--accent-color);
            background: var(--bg-tertiary);
        }
        
        .lang-option-radio {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .lang-option.selected .lang-option-radio {
            border-color: var(--accent-color);
        }
        
        .lang-option.selected .lang-option-radio::after {
            content: '';
            width: 10px;
            height: 10px;
            background: var(--accent-color);
            border-radius: 50%;
        }
        
        .lang-option-text {
            font-size: 15px;
            color: var(--text-primary);
        }
        
        .lang-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
        }
        
        .lang-modal-footer button {
            padding: 8px 20px;
            font-size: 14px;
        }
        
        .btn-cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-cancel:hover {
            background: var(--border-color);
        }
        
        /* Code viewer modal styles */
        .code-viewer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }
        
        .code-viewer-overlay.active {
            display: flex;
        }
        
        .code-viewer-modal {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 100%;
            height: 100%;
            max-width: calc(100vw - 40px);
            max-height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
            animation: codeViewerSlideIn 0.2s ease-out;
        }
        
        @keyframes codeViewerSlideIn {
            from {
                opacity: 0;
                transform: scale(0.98);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .code-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .code-viewer-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .code-viewer-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .btn-copy-code {
            background: #27ae60;
            padding: 8px 16px;
            font-size: 14px;
        }
        
        .btn-copy-code:hover {
            background: #219a52;
        }
        
        .code-viewer-close {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 24px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
            padding: 0;
        }
        
        .code-viewer-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .code-viewer-body {
            flex: 1;
            overflow: auto;
            padding: 20px;
            background: var(--bg-tertiary);
        }
        
        .code-content {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-primary);
            white-space: pre;
            margin: 0;
        }
        
        .code-line {
            display: flex;
            padding: 2px 0;
        }
        
        .code-line:hover {
            background: var(--bg-secondary);
        }
        
        .line-number {
            color: var(--text-muted);
            min-width: 50px;
            padding-right: 16px;
            text-align: right;
            user-select: none;
            border-right: 1px solid var(--border-color);
            margin-right: 16px;
        }
        
        .line-content {
            flex: 1;
        }
        
        /* View code button */
        .btn-view-code {
            background: #27ae60;
        }
        
        .btn-view-code:hover {
            background: #219a52;
        }
    </style>
</head>
<body>
    <!-- Language selector button -->
    <div class="lang-selector">
        <button class="lang-btn" id="langBtn">
            <span class="globe-icon">üåê</span>
            <span id="langBtnText">‰∏≠Êñá</span>
        </button>
    </div>
    
    <!-- Language selection modal -->
    <div class="lang-modal-overlay" id="langModal">
        <div class="lang-modal">
            <div class="lang-modal-header">
                <span class="lang-modal-title" data-i18n="language">ËØ≠Ë®Ä</span>
                <button class="lang-modal-close" id="langModalClose">√ó</button>
            </div>
            <div class="lang-modal-body">
                <div class="lang-option selected" data-lang="zh">
                    <div class="lang-option-radio"></div>
                    <span class="lang-option-text">‰∏≠Êñá</span>
                </div>
                <div class="lang-option" data-lang="en">
                    <div class="lang-option-radio"></div>
                    <span class="lang-option-text">English</span>
                </div>
            </div>
            <div class="lang-modal-footer">
                <button class="btn-cancel" id="langCancelBtn" data-i18n="cancel">ÂèñÊ∂à</button>
                <button id="langConfirmBtn" data-i18n="confirm">Á°ÆËÆ§</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="main-content">
            <div class="input-section">
                <h2>üì§ ‰∏ä‰º† GGB Êñá‰ª∂</h2>
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-icon">üìÅ</div>
                    <div class="drop-zone-text">ÊãñÊãΩ GGB Êñá‰ª∂Âà∞ËøôÈáåÔºåÊàñÁÇπÂáª‰∏ä‰º†</div>
                    <div class="drop-zone-hint">ÊîØÊåÅ .ggb Ê†ºÂºè (GeoGebra Êñá‰ª∂)</div>
                </div>
                <input type="file" id="fileInput" accept=".ggb">
                <div id="fileName" class="file-name" style="display: none;"></div>
                
                <div class="options">
                    <label>
                        <input type="checkbox" id="includePoints" checked> ÂåÖÂê´ÁÇπÊ†áËÆ∞
                    </label>
                    <label>
                        <input type="checkbox" id="includeLabels" checked> ÂåÖÂê´ÁÇπÊ†áÁ≠æ
                    </label>
                    <label>
                        <input type="checkbox" id="roundCoordinates" checked> ÂùêÊ†áÂõõËàç‰∫îÂÖ•Âà∞3‰ΩçÂ∞èÊï∞
                    </label>
                    <label>
                        <input type="checkbox" id="includeAxes"> ÂåÖÂê´ÂùêÊ†áËΩ¥
                    </label>
                    <label>
                        <input type="checkbox" id="includeGrid"> ÂåÖÂê´ÁΩëÊ†º
                    </label>
                    <label>
                        <input type="checkbox" id="blackAndWhite"> ÈªëÁôΩÂåñÔºàÂøΩÁï•ÂéüÂßãÈ¢úËâ≤Ôºâ
                    </label>
                </div>
                
                <div class="range-settings">
                    <h4>üìê ÂúÜÈî•Êõ≤Á∫øÁªòÂà∂ËåÉÂõ¥</h4>
                    <label>
                        <input type="checkbox" id="enableClipRange"> ÂêØÁî®ÁªòÂà∂ËåÉÂõ¥ÈôêÂà∂
                    </label>
                    <div class="range-row">
                        <label>X ËåÉÂõ¥:</label>
                        <input type="number" id="clipXmin" value="-10" step="0.5">
                        <span class="separator">~</span>
                        <input type="number" id="clipXmax" value="10" step="0.5">
                    </div>
                    <div class="range-row">
                        <label>Y ËåÉÂõ¥:</label>
                        <input type="number" id="clipYmin" value="-10" step="0.5">
                        <span class="separator">~</span>
                        <input type="number" id="clipYmax" value="10" step="0.5">
                    </div>
                    <p class="range-hint">ÂêØÁî®ÂêéÔºåÊ§≠ÂúÜ„ÄÅÂèåÊõ≤Á∫ø„ÄÅÊäõÁâ©Á∫øÁ≠âÊó†ÈôêÂª∂‰º∏ÁöÑÊõ≤Á∫øÂ∞ÜË¢´Ë£ÅÂâ™Âà∞ÊåáÂÆöËåÉÂõ¥ÂÜÖ</p>
                </div>
                
                <div id="functionSettings" class="function-settings">
                    <h4>üìà ÂáΩÊï∞Êõ≤Á∫øÁªòÂà∂ËåÉÂõ¥</h4>
                    <div id="functionList">
                        <div class="no-functions">‰∏ä‰º† GGB Êñá‰ª∂ÂêéÔºåÊ£ÄÊµãÂà∞ÁöÑÂáΩÊï∞Â∞ÜÊòæÁ§∫Âú®ËøôÈáå</div>
                    </div>
                </div>
                
                <div id="elementInfo" class="element-info" style="display: none;">
                    <h4>Ê£ÄÊµãÂà∞ÁöÑÂÖÉÁ¥†:</h4>
                    <div id="elementList" class="element-list"></div>
                </div>
            </div>
            
            <div class="output-section">
                <h2>üìù TikZ ‰ª£Á†Å</h2>
                <textarea id="outputCode" readonly placeholder="ËΩ¨Êç¢ÂêéÁöÑ TikZ ‰ª£Á†ÅÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå..."></textarea>
                
                <div class="controls">
                    <button id="copyBtn">
                        üìã Â§çÂà∂‰ª£Á†Å
                    </button>
                    <button id="viewCodeBtn" class="btn-view-code" style="display: none;">
                        üëÅÔ∏è Êü•Áúã‰ª£Á†Å
                    </button>
                    <button id="clearBtn">
                        üóëÔ∏è Ê∏ÖÁ©∫
                    </button>
                </div>
                
                <div class="info-links">
                    <p>ÂèÇËÄÉËµÑÊ∫ê:</p>
                    <p>‚Ä¢ <a href="https://tikz.dev/" target="_blank">TikZ ÂÆòÊñπÊñáÊ°£</a></p>
                    <p>‚Ä¢ <a href="https://www.overleaf.com/learn/latex/TikZ_package" target="_blank">Overleaf TikZ ÊïôÁ®ã</a></p>
                    <p>‚Ä¢ <a href="https://geogebra.github.io/docs/reference/en/" target="_blank">GeoGebra ÂëΩ‰ª§ÂèÇËÄÉ</a></p>
                </div>
                
                <p style="font-size: 12px; color: var(--text-muted); margin-top: 15px;">Ê≥®ÊÑèÔºöGeoGebra Âπ≥Èù¢ÂÜÖÁöÑ 1 ‰∏™Âçï‰ΩçÈïøÂ∫¶ÂØπÂ∫î TikZ ÁöÑ 1cm</p>
                
                <div class="theme-toggle">
                    <span class="theme-toggle-label">üåì ÊöóËâ≤‰∏ªÈ¢ò</span>
                    <label class="theme-switch">
                        <input type="checkbox" id="themeToggle">
                        <span class="theme-slider"></span>
                    </label>
                </div>
                
                <div class="github-link">
                    <a href="https://github.com/Gitdown-and/GGB2TikZ---GeoGebra-to-TikZ-Converter" target="_blank">
                        GitHub: https://github.com/Gitdown-and/GGB2TikZ---GeoGebra-to-TikZ-Converter
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <div id="notification" class="notification"></div>
    
    <!-- Code viewer modal -->
    <div class="code-viewer-overlay" id="codeViewerModal">
        <div class="code-viewer-modal">
            <div class="code-viewer-header">
                <span class="code-viewer-title" id="codeViewerTitle">‰ª£Á†ÅÂå∫</span>
                <div class="code-viewer-actions">
                    <button id="codeViewerCopyBtn" class="btn-copy-code">üìã Â§çÂà∂</button>
                    <button class="code-viewer-close" id="codeViewerClose">√ó</button>
                </div>
            </div>
            <div class="code-viewer-body">
                <div class="code-content" id="codeContent"></div>
            </div>
        </div>
    </div>

    <!-- JSZip library for extracting ggb files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <script>
        // Internationalization (i18n) system
        const i18n = {
            zh: {
                // Page title
                title: 'GGB to TikZ ËΩ¨Êç¢Âô®',
                // Language selector
                langBtn: '‰∏≠Êñá',
                language: 'ËØ≠Ë®Ä',
                cancel: 'ÂèñÊ∂à',
                confirm: 'Á°ÆËÆ§',
                // Upload section
                uploadTitle: 'üì§ ‰∏ä‰º† GGB Êñá‰ª∂',
                dropzoneText: 'ÊãñÊãΩ GGB Êñá‰ª∂Âà∞ËøôÈáåÔºåÊàñÁÇπÂáª‰∏ä‰º†',
                dropzoneHint: 'ÊîØÊåÅ .ggb Ê†ºÂºè (GeoGebra Êñá‰ª∂)',
                // Options
                includePoints: 'ÂåÖÂê´ÁÇπÊ†áËÆ∞',
                includeLabels: 'ÂåÖÂê´ÁÇπÊ†áÁ≠æ',
                roundCoordinates: 'ÂùêÊ†áÂõõËàç‰∫îÂÖ•Âà∞3‰ΩçÂ∞èÊï∞',
                includeAxes: 'ÂåÖÂê´ÂùêÊ†áËΩ¥',
                includeGrid: 'ÂåÖÂê´ÁΩëÊ†º',
                blackAndWhite: 'ÈªëÁôΩÂåñÔºàÂøΩÁï•ÂéüÂßãÈ¢úËâ≤Ôºâ',
                // Conic range settings
                conicRangeTitle: 'üìê ÂúÜÈî•Êõ≤Á∫øÁªòÂà∂ËåÉÂõ¥',
                enableClipRange: 'ÂêØÁî®ÁªòÂà∂ËåÉÂõ¥ÈôêÂà∂',
                xRange: 'X ËåÉÂõ¥:',
                yRange: 'Y ËåÉÂõ¥:',
                conicRangeHint: 'ÂêØÁî®ÂêéÔºåÊ§≠ÂúÜ„ÄÅÂèåÊõ≤Á∫ø„ÄÅÊäõÁâ©Á∫øÁ≠âÊó†ÈôêÂª∂‰º∏ÁöÑÊõ≤Á∫øÂ∞ÜË¢´Ë£ÅÂâ™Âà∞ÊåáÂÆöËåÉÂõ¥ÂÜÖ',
                // Function settings
                functionRangeTitle: 'üìà ÂáΩÊï∞Êõ≤Á∫øÁªòÂà∂ËåÉÂõ¥',
                noFunctions: '‰∏ä‰º† GGB Êñá‰ª∂ÂêéÔºåÊ£ÄÊµãÂà∞ÁöÑÂáΩÊï∞Â∞ÜÊòæÁ§∫Âú®ËøôÈáå',
                plotInterval: 'ÁªòÂà∂Âå∫Èó¥:',
                functionRangeHint: 'Ê†ºÂºè: Ëµ∑Âßã1,ÁªìÊùü1+Ëµ∑Âßã2,ÁªìÊùü2+... ÔºàÁî®+ÂàÜÈöîÂ§ö‰∏™Âå∫Èó¥ÔºåÈªòËÆ§‰ΩøÁî®Êï¥‰ΩìËåÉÂõ¥Ôºâ',
                dashed: 'ËôöÁ∫ø',
                solid: 'ÂÆûÁ∫ø',
                // Element info
                detectedElements: 'Ê£ÄÊµãÂà∞ÁöÑÂÖÉÁ¥†:',
                // Output section
                outputTitle: 'üìù TikZ ‰ª£Á†Å',
                outputPlaceholder: 'ËΩ¨Êç¢ÂêéÁöÑ TikZ ‰ª£Á†ÅÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå...',
                copyCode: 'üìã Â§çÂà∂‰ª£Á†Å',
                clear: 'üóëÔ∏è Ê∏ÖÁ©∫',
                // Info links
                resources: 'ÂèÇËÄÉËµÑÊ∫ê:',
                tikzDocs: 'TikZ ÂÆòÊñπÊñáÊ°£',
                overleafTutorial: 'Overleaf TikZ ÊïôÁ®ã',
                geogebraRef: 'GeoGebra ÂëΩ‰ª§ÂèÇËÄÉ',
                // Unit hint
                unitHint: 'Ê≥®ÊÑèÔºöGeoGebra Âπ≥Èù¢ÂÜÖÁöÑ 1 ‰∏™Âçï‰ΩçÈïøÂ∫¶ÂØπÂ∫î TikZ ÁöÑ 1cm',
                // Theme
                darkTheme: 'üåì ÊöóËâ≤‰∏ªÈ¢ò',
                // Notifications
                langChanged: 'ËØ≠Ë®ÄÂ∑≤Êõ¥Êç¢‰∏∫',
                copySuccess: '‰ª£Á†ÅÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø',
                copyFailed: 'Â§çÂà∂Â§±Ë¥•: ',
                noContent: 'Ê≤°ÊúâÂèØÂ§çÂà∂ÁöÑÂÜÖÂÆπ',
                cleared: 'Â∑≤Ê∏ÖÁ©∫',
                convertSuccess: 'ÊàêÂäüËΩ¨Êç¢ÔºÅÂÖ±Ê£ÄÊµãÂà∞',
                elements: '‰∏™ÂÖÉÁ¥†',
                processError: 'Â§ÑÁêÜÊñá‰ª∂Êó∂Âá∫Èîô: ',
                invalidFormat: 'ËØ∑‰∏ä‰º† .ggb Ê†ºÂºèÁöÑÊñá‰ª∂',
                xmlNotFound: 'Êâæ‰∏çÂà∞ geogebra.xml Êñá‰ª∂',
                // Element tags
                point: 'ÁÇπ',
                segment: 'Á∫øÊÆµ',
                line: 'Áõ¥Á∫ø',
                ray: 'Â∞ÑÁ∫ø',
                vector: 'ÂêëÈáè',
                circle: 'ÂúÜ',
                ellipse: 'Ê§≠ÂúÜ',
                hyperbola: 'ÂèåÊõ≤Á∫ø',
                parabola: 'ÊäõÁâ©Á∫ø',
                arc: 'ÂúÜÂºß',
                sector: 'ÊâáÂΩ¢',
                polygon: 'Â§öËæπÂΩ¢',
                function: 'ÂáΩÊï∞',
                angle: 'ËßíÂ∫¶',
                // Code viewer
                viewCode: 'üëÅÔ∏è Êü•Áúã‰ª£Á†Å',
                codeArea: '‰ª£Á†ÅÂå∫',
                copy: 'üìã Â§çÂà∂',
                github: 'GitHub'
            },
            en: {
                // Page title
                title: 'GGB to TikZ Converter',
                // Language selector
                langBtn: 'English',
                language: 'Language',
                cancel: 'Cancel',
                confirm: 'Confirm',
                // Upload section
                uploadTitle: 'üì§ Upload GGB File',
                dropzoneText: 'Drag and drop GGB file here, or click to upload',
                dropzoneHint: 'Supports .ggb format (GeoGebra file)',
                // Options
                includePoints: 'Include point markers',
                includeLabels: 'Include point labels',
                roundCoordinates: 'Round coordinates to 3 decimal places',
                includeAxes: 'Include coordinate axes',
                includeGrid: 'Include grid',
                blackAndWhite: 'Black & white (ignore original colors)',
                // Conic range settings
                conicRangeTitle: 'üìê Conic Plotting Range',
                enableClipRange: 'Enable plotting range limit',
                xRange: 'X Range:',
                yRange: 'Y Range:',
                conicRangeHint: 'When enabled, infinitely extending curves like ellipses, hyperbolas, and parabolas will be clipped to the specified range',
                // Function settings
                functionRangeTitle: 'üìà Function Plotting Range',
                noFunctions: 'Detected functions will appear here after uploading a GGB file',
                plotInterval: 'Plot interval:',
                functionRangeHint: 'Format: start1,end1+start2,end2+... (separate multiple intervals with +, defaults to overall range)',
                dashed: 'Dashed',
                solid: 'Solid',
                // Element info
                detectedElements: 'Detected elements:',
                // Output section
                outputTitle: 'üìù TikZ Code',
                outputPlaceholder: 'Converted TikZ code will appear here...',
                copyCode: 'üìã Copy Code',
                clear: 'üóëÔ∏è Clear',
                // Info links
                resources: 'Resources:',
                tikzDocs: 'TikZ Documentation',
                overleafTutorial: 'Overleaf TikZ Tutorial',
                geogebraRef: 'GeoGebra Command Reference',
                // Unit hint
                unitHint: 'Note: 1 unit in GeoGebra corresponds to 1cm in TikZ',
                // Theme
                darkTheme: 'üåì Dark Theme',
                // Notifications
                langChanged: 'Language changed to',
                copySuccess: 'Code copied to clipboard',
                copyFailed: 'Copy failed: ',
                noContent: 'No content to copy',
                cleared: 'Cleared',
                convertSuccess: 'Conversion successful! Detected',
                elements: 'elements',
                processError: 'Error processing file: ',
                invalidFormat: 'Please upload a .ggb file',
                xmlNotFound: 'geogebra.xml file not found',
                // Element tags
                point: 'Point',
                segment: 'Segment',
                line: 'Line',
                ray: 'Ray',
                vector: 'Vector',
                circle: 'Circle',
                ellipse: 'Ellipse',
                hyperbola: 'Hyperbola',
                parabola: 'Parabola',
                arc: 'Arc',
                sector: 'Sector',
                polygon: 'Polygon',
                function: 'Function',
                angle: 'Angle',
                // Code viewer
                viewCode: 'üëÅÔ∏è View Code',
                codeArea: 'Code Area',
                copy: 'üìã Copy',
                github: 'GitHub'
            }
        };
        
        // Current language
        let currentLang = localStorage.getItem('lang') || 'zh';
        let selectedLang = currentLang; // For modal selection
        
        // Global storage for parsed data (must be global for language switching)
        let parsedElements = {
            points: {},
            segments: [],
            lines: [],
            rays: [],
            vectors: [],
            circles: [],
            ellipses: [],
            parabolas: [],
            hyperbolas: [],
            arcs: [],
            sectors: [],
            polygons: [],
            functions: [],
            angles: [],
            texts: []
        };
        
        // Get translation
        function t(key) {
            return i18n[currentLang][key] || i18n['zh'][key] || key;
        }
        
        // Update all text content
        function updateUIText() {
            // Update page title
            document.title = t('title');
            document.documentElement.lang = currentLang === 'zh' ? 'zh' : 'en';
            
            // Update language button text
            document.getElementById('langBtnText').textContent = t('langBtn');
            
            // Update modal title and buttons
            document.querySelector('.lang-modal-title').textContent = t('language');
            document.getElementById('langCancelBtn').textContent = t('cancel');
            document.getElementById('langConfirmBtn').textContent = t('confirm');
            
            // Update section titles
            document.querySelector('.input-section h2').textContent = t('uploadTitle');
            document.querySelector('.output-section h2').textContent = t('outputTitle');
            
            // Update dropzone
            document.querySelector('.drop-zone-text').textContent = t('dropzoneText');
            document.querySelector('.drop-zone-hint').textContent = t('dropzoneHint');
            
            // Update options - preserve checkbox states
            const optionIds = ['includePoints', 'includeLabels', 'roundCoordinates', 'includeAxes', 'includeGrid', 'blackAndWhite'];
            const optionKeys = ['includePoints', 'includeLabels', 'roundCoordinates', 'includeAxes', 'includeGrid', 'blackAndWhite'];
            const optionLabels = document.querySelectorAll('.options label');
            
            optionLabels.forEach((label, index) => {
                const checkbox = document.getElementById(optionIds[index]);
                const isChecked = checkbox ? checkbox.checked : (index < 3); // Default: first 3 are checked
                label.innerHTML = `<input type="checkbox" id="${optionIds[index]}"${isChecked ? ' checked' : ''}> ${t(optionKeys[index])}`;
            });
            
            // Re-attach event listeners for options
            optionIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', () => {
                        if (Object.keys(parsedElements.points).length > 0 || parsedElements.segments.length > 0) {
                            outputCode.value = generateTikZCode();
                        }
                    });
                }
            });
            
            // Update range settings
            document.querySelector('.range-settings h4').textContent = t('conicRangeTitle');
            const rangeLabels = document.querySelectorAll('.range-row label');
            rangeLabels[0].textContent = t('xRange');
            rangeLabels[1].textContent = t('yRange');
            
            // Preserve enableClipRange checkbox state
            const clipRangeCheckbox = document.getElementById('enableClipRange');
            const isClipRangeChecked = clipRangeCheckbox ? clipRangeCheckbox.checked : false;
            document.querySelector('.range-settings > label').innerHTML = `<input type="checkbox" id="enableClipRange"${isClipRangeChecked ? ' checked' : ''}> ${t('enableClipRange')}`;
            document.querySelector('.range-hint').textContent = t('conicRangeHint');
            
            // Re-attach enableClipRange listener
            document.getElementById('enableClipRange').addEventListener('change', () => {
                if (Object.keys(parsedElements.points).length > 0 || parsedElements.segments.length > 0) {
                    outputCode.value = generateTikZCode();
                }
            });
            
            // Update function settings
            document.querySelector('#functionSettings h4').textContent = t('functionRangeTitle');
            document.querySelector('.no-functions').textContent = t('noFunctions');
            
            // Update output section
            document.getElementById('outputCode').placeholder = t('outputPlaceholder');
            document.getElementById('copyBtn').innerHTML = t('copyCode');
            document.getElementById('viewCodeBtn').innerHTML = t('viewCode');
            document.getElementById('clearBtn').innerHTML = t('clear');
            
            // Update code viewer modal
            document.getElementById('codeViewerTitle').textContent = t('codeArea');
            document.getElementById('codeViewerCopyBtn').textContent = t('copy');
            
            // Update info links
            const infoLinksP = document.querySelectorAll('.info-links p');
            infoLinksP[0].textContent = t('resources');
            infoLinksP[1].innerHTML = `‚Ä¢ <a href="https://tikz.dev/" target="_blank">${t('tikzDocs')}</a>`;
            infoLinksP[2].innerHTML = `‚Ä¢ <a href="https://www.overleaf.com/learn/latex/TikZ_package" target="_blank">${t('overleafTutorial')}</a>`;
            infoLinksP[3].innerHTML = `‚Ä¢ <a href="https://geogebra.github.io/docs/reference/en/" target="_blank">${t('geogebraRef')}</a>`;
            
            // Update unit hint
            document.querySelector('.output-section p[style*="font-size: 12px"]').textContent = t('unitHint');
            
            // Update theme toggle
            document.querySelector('.theme-toggle-label').textContent = t('darkTheme');
            
            // Update GitHub link
            const githubLinkSpan = document.querySelector('.github-link span[data-i18n="github"]');
            if (githubLinkSpan) {
                githubLinkSpan.textContent = t('github');
            }
            
            // Update element info title if visible
            const elementInfoTitle = document.querySelector('#elementInfo h4');
            if (elementInfoTitle) {
                elementInfoTitle.textContent = t('detectedElements');
            }
            
            // Update element tags if visible
            updateElementTags();
            
            // Update function list if functions exist
            if (typeof parsedElements !== 'undefined' && parsedElements.functions && parsedElements.functions.length > 0) {
                updateFunctionList();
            }
        }
        
        // Update element tags (for language change)
        function updateElementTags() {
            const elementList = document.getElementById('elementList');
            if (!elementList || elementList.children.length === 0) return;
            
            elementList.innerHTML = '';
            
            const addTag = (text, color = '#3498db') => {
                const tag = document.createElement('span');
                tag.className = 'element-tag';
                tag.style.background = color;
                tag.textContent = text;
                elementList.appendChild(tag);
            };
            
            if (typeof parsedElements !== 'undefined') {
                if (Object.keys(parsedElements.points).length > 0) addTag(`${t('point')} √ó${Object.keys(parsedElements.points).length}`, '#e74c3c');
                if (parsedElements.segments.length > 0) addTag(`${t('segment')} √ó${parsedElements.segments.length}`, '#3498db');
                if (parsedElements.lines.length > 0) addTag(`${t('line')} √ó${parsedElements.lines.length}`, '#2ecc71');
                if (parsedElements.rays.length > 0) addTag(`${t('ray')} √ó${parsedElements.rays.length}`, '#f39c12');
                if (parsedElements.vectors.length > 0) addTag(`${t('vector')} √ó${parsedElements.vectors.length}`, '#9b59b6');
                if (parsedElements.circles.length > 0) addTag(`${t('circle')} √ó${parsedElements.circles.length}`, '#1abc9c');
                if (parsedElements.ellipses.length > 0) addTag(`${t('ellipse')} √ó${parsedElements.ellipses.length}`, '#e67e22');
                if (parsedElements.hyperbolas.length > 0) addTag(`${t('hyperbola')} √ó${parsedElements.hyperbolas.length}`, '#c0392b');
                if (parsedElements.parabolas.length > 0) addTag(`${t('parabola')} √ó${parsedElements.parabolas.length}`, '#8e44ad');
                if (parsedElements.arcs.length > 0) addTag(`${t('arc')} √ó${parsedElements.arcs.length}`, '#16a085');
                if (parsedElements.sectors.length > 0) addTag(`${t('sector')} √ó${parsedElements.sectors.length}`, '#27ae60');
                if (parsedElements.polygons.length > 0) addTag(`${t('polygon')} √ó${parsedElements.polygons.length}`, '#2980b9');
                if (parsedElements.functions.length > 0) addTag(`${t('function')} √ó${parsedElements.functions.length}`, '#006758');
                if (parsedElements.angles.length > 0) addTag(`${t('angle')} √ó${parsedElements.angles.length}`, '#d35400');
            }
        }
        
        // Language modal functions
        function openLangModal() {
            selectedLang = currentLang;
            updateLangOptions();
            document.getElementById('langModal').classList.add('active');
        }
        
        function closeLangModal() {
            document.getElementById('langModal').classList.remove('active');
        }
        
        function updateLangOptions() {
            document.querySelectorAll('.lang-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.lang === selectedLang);
            });
        }
        
        function confirmLanguageChange() {
            if (selectedLang !== currentLang) {
                currentLang = selectedLang;
                localStorage.setItem('lang', currentLang);
                updateUIText();
                // showNotification will be called after DOMContentLoaded if available
                if (typeof showNotification === 'function') {
                    showNotification(`${t('langChanged')} ${currentLang === 'zh' ? '‰∏≠Êñá' : 'English'}`);
                }
            }
            closeLangModal();
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize language
            updateUIText();
            
            // Language modal event listeners
            document.getElementById('langBtn').addEventListener('click', openLangModal);
            document.getElementById('langModalClose').addEventListener('click', closeLangModal);
            document.getElementById('langCancelBtn').addEventListener('click', closeLangModal);
            document.getElementById('langConfirmBtn').addEventListener('click', confirmLanguageChange);
            
            // Language option selection
            document.querySelectorAll('.lang-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    selectedLang = opt.dataset.lang;
                    updateLangOptions();
                    // Update modal text based on selected language
                    const modalTitle = document.querySelector('.lang-modal-title');
                    const cancelBtn = document.getElementById('langCancelBtn');
                    const confirmBtn = document.getElementById('langConfirmBtn');
                    if (selectedLang === 'zh') {
                        modalTitle.textContent = 'ËØ≠Ë®Ä';
                        cancelBtn.textContent = 'ÂèñÊ∂à';
                        confirmBtn.textContent = 'Á°ÆËÆ§';
                    } else {
                        modalTitle.textContent = 'Language';
                        cancelBtn.textContent = 'Cancel';
                        confirmBtn.textContent = 'Confirm';
                    }
                });
            });
            
            // Close modal when clicking outside
            document.getElementById('langModal').addEventListener('click', (e) => {
                if (e.target.id === 'langModal') {
                    closeLangModal();
                }
            });
            
            // Theme toggle functionality
            const themeToggle = document.getElementById('themeToggle');
            const savedTheme = localStorage.getItem('theme') || 'light';
            
            if (savedTheme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeToggle.checked = true;
            }
            
            themeToggle.addEventListener('change', function() {
                if (this.checked) {
                    document.documentElement.setAttribute('data-theme', 'dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.documentElement.setAttribute('data-theme', 'light');
                    localStorage.setItem('theme', 'light');
                }
            });
            
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            const outputCode = document.getElementById('outputCode');
            const copyBtn = document.getElementById('copyBtn');
            const viewCodeBtn = document.getElementById('viewCodeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const notification = document.getElementById('notification');
            const fileName = document.getElementById('fileName');
            const elementInfo = document.getElementById('elementInfo');
            const elementList = document.getElementById('elementList');
            
            // Code viewer elements
            const codeViewerModal = document.getElementById('codeViewerModal');
            const codeContent = document.getElementById('codeContent');
            const codeViewerClose = document.getElementById('codeViewerClose');
            const codeViewerCopyBtn = document.getElementById('codeViewerCopyBtn');
            
            // Reset parsed elements (global variable)
            parsedElements = {
                points: {},
                segments: [],
                lines: [],
                rays: [],
                vectors: [],
                circles: [],
                ellipses: [],
                parabolas: [],
                hyperbolas: [],
                arcs: [],
                sectors: [],
                polygons: [],
                functions: [],
                angles: [],
                texts: []
            };
            
            let viewSettings = {
                xZero: 0,
                yZero: 0,
                scale: 1,
                yscale: 1,
                xmin: -10,
                xmax: 10,
                ymin: -10,
                ymax: 10
            };
            
            // Store function plotting ranges: { label: "min1,max1+min2,max2+..." }
            let functionRanges = {};
            
            // Show notification (make it globally accessible for language change)
            window.showNotification = function(message, isError = false) {
                notification.textContent = message;
                notification.className = 'notification';
                if (isError) {
                    notification.classList.add('error');
                }
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            };
            
            // Code viewer functions
            function openCodeViewer() {
                if (!outputCode.value) return;
                
                // Update title and button text with current language
                document.getElementById('codeViewerTitle').textContent = t('codeArea');
                document.getElementById('codeViewerCopyBtn').textContent = t('copy');
                
                // Generate code with line numbers
                const lines = outputCode.value.split('\n');
                let html = '';
                lines.forEach((line, index) => {
                    html += `<div class="code-line"><span class="line-number">${index + 1}</span><span class="line-content">${escapeHtml(line)}</span></div>`;
                });
                codeContent.innerHTML = html;
                codeViewerModal.classList.add('active');
                // Hide language selector while code viewer is open
                document.querySelector('.lang-selector').style.display = 'none';
            }
            
            function closeCodeViewer() {
                codeViewerModal.classList.remove('active');
                // Show language selector when code viewer is closed
                document.querySelector('.lang-selector').style.display = 'block';
            }
            
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            function updateViewCodeButton() {
                if (outputCode.value.trim()) {
                    viewCodeBtn.style.display = 'flex';
                } else {
                    viewCodeBtn.style.display = 'none';
                }
            }
            
            // Update function list in the settings panel
            function updateFunctionList() {
                const functionSettings = document.getElementById('functionSettings');
                const functionList = document.getElementById('functionList');
                
                if (parsedElements.functions.length === 0) {
                    functionSettings.classList.remove('active');
                    functionList.innerHTML = `<div class="no-functions">${t('noFunctions')}</div>`;
                    return;
                }
                
                functionSettings.classList.add('active');
                functionList.innerHTML = '';
                
                parsedElements.functions.forEach((func, index) => {
                    const funcItem = document.createElement('div');
                    funcItem.className = 'function-item';
                    
                    // Determine line style display
                    const isDashed = func.lineStyle.includes('dashed');
                    const styleTag = isDashed ? 
                        `<span class="function-style-tag dashed">${t('dashed')}</span>` : 
                        `<span class="function-style-tag">${t('solid')}</span>`;
                    
                    // Get expression (original GGB expression or fallback)
                    const exprDisplay = func.originalExpression || func.expression || `${func.label}(x)`;
                    
                    const placeholderText = currentLang === 'zh' ? '‰æãÂ¶Ç: -5,5+10,20' : 'e.g.: -5,5+10,20';
                    
                    funcItem.innerHTML = `
                        <div class="function-header">
                            <code class="function-expr">${exprDisplay}</code>
                            <div class="function-color-preview" style="background: ${func.color};" title="${func.color}"></div>
                            ${styleTag}
                        </div>
                        <div class="function-range-row">
                            <label>${t('plotInterval')}</label>
                            <input type="text" 
                                   id="funcRange_${func.label}" 
                                   value="${functionRanges[func.label] || ''}" 
                                   placeholder="${placeholderText}">
                        </div>
                        <p class="function-range-hint">${t('functionRangeHint')}</p>
                    `;
                    
                    functionList.appendChild(funcItem);
                    
                    // Add event listener for range input
                    const rangeInput = funcItem.querySelector(`#funcRange_${func.label}`);
                    rangeInput.addEventListener('input', (e) => {
                        functionRanges[func.label] = e.target.value.trim();
                        // Regenerate TikZ code when range changes
                        if (Object.keys(parsedElements.points).length > 0 || parsedElements.functions.length > 0) {
                            outputCode.value = generateTikZCode();
                        }
                    });
                });
            }
            
            // Round number to 3 decimal places
            function roundNum(num) {
                if (document.getElementById('roundCoordinates').checked) {
                    return Math.round(num * 1000) / 1000;
                }
                return num;
            }
            
            // RGB to hex color
            function rgbToHex(r, g, b) {
                const toHex = (c) => {
                    const hex = parseInt(c).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                return '#' + toHex(r) + toHex(g) + toHex(b);
            }
            
            // Get line style
            // GeoGebra thickness range: 1-13, default 5
            // Convert to reasonable TikZ line width: 0.4-1.2pt range
            // GeoGebra lineStyle type: 0 = solid, >0 = various dashed styles
            function getLineStyle(lineStyle, defaultThickness = 5) {
                // If no lineStyle element, return default style
                if (!lineStyle) {
                    const lineWidth = Math.max(0.4, Math.min(1.2, defaultThickness * 0.2));
                    return 'line width=' + lineWidth.toFixed(2) + 'pt, solid';
                }
                
                const type = parseInt(lineStyle.getAttribute('type') || '0');
                const thickness = parseInt(lineStyle.getAttribute('thickness') || String(defaultThickness));
                // Map thickness 1-13 to line width 0.4-1.2pt
                const lineWidth = Math.max(0.4, Math.min(1.2, thickness * 0.2));
                let style = 'line width=' + lineWidth.toFixed(2) + 'pt';
                
                // GeoGebra type: 0 = solid, any non-zero value = dashed
                if (type === 0) {
                    style += ', solid';
                } else {
                    style += ', dashed';
                }
                return style;
            }
            
            // Parse coordinates from element
            function parseCoords(element) {
                const coords = element.querySelector('coords');
                if (coords) {
                    const x = parseFloat(coords.getAttribute('x'));
                    const y = parseFloat(coords.getAttribute('y'));
                    const z = parseFloat(coords.getAttribute('z') || '1');
                    if (z !== 0) {
                        return { x: x / z, y: y / z };
                    }
                }
                return null;
            }
            
            // Parse point
            function parsePoint(element) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const coords = parseCoords(element);
                if (!coords) return null;
                
                const color = element.querySelector('objColor');
                const pointSize = element.querySelector('pointSize');
                const lineStyle = element.querySelector('lineStyle');
                
                return {
                    label: label,
                    x: coords.x,
                    y: coords.y,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#1565C0',
                    size: pointSize ? parseInt(pointSize.getAttribute('val')) : 5,
                    lineStyle: getLineStyle(lineStyle)
                };
            }
            
            // Parse segment
            function parseSegment(element, expression) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const color = element.querySelector('objColor');
                const lineStyle = element.querySelector('lineStyle');
                
                // Get endpoints from coords (homogeneous coordinates)
                const coords = element.querySelector('coords');
                let start = null, end = null;
                
                // Segments in GGB have coords that define the line equation
                // We need to find the endpoints from the expression or use stored points
                const expMatch = expression ? expression.match(/Segment\[(\w+),\s*(\w+)\]/) : null;
                
                return {
                    label: label,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#000000',
                    lineStyle: getLineStyle(lineStyle),
                    startLabel: expMatch ? expMatch[1] : null,
                    endLabel: expMatch ? expMatch[2] : null,
                    coords: coords ? {
                        x: parseFloat(coords.getAttribute('x')),
                        y: parseFloat(coords.getAttribute('y')),
                        z: parseFloat(coords.getAttribute('z'))
                    } : null
                };
            }
            
            // Parse line
            function parseLine(element, expression) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const color = element.querySelector('objColor');
                const lineStyle = element.querySelector('lineStyle');
                const coords = element.querySelector('coords');
                
                // Line equation: ax + by + c = 0, stored as (a, b, c)
                // Get points from expression
                const expMatch = expression ? expression.match(/Line\[(\w+),\s*(\w+)\]|OrthogonalLine\[(\w+),\s*(\w+)\]/) : null;
                
                return {
                    label: label,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#000000',
                    lineStyle: getLineStyle(lineStyle),
                    pointLabels: expMatch ? (expMatch[1] ? [expMatch[1], expMatch[2]] : [expMatch[3], expMatch[4]]) : null,
                    coords: coords ? {
                        a: parseFloat(coords.getAttribute('x')),
                        b: parseFloat(coords.getAttribute('y')),
                        c: parseFloat(coords.getAttribute('z'))
                    } : null
                };
            }
            
            // Parse ray
            function parseRay(element, expression) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const color = element.querySelector('objColor');
                const lineStyle = element.querySelector('lineStyle');
                
                const expMatch = expression ? expression.match(/Ray\[(\w+),\s*(\w+)\]/) : null;
                
                return {
                    label: label,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#000000',
                    lineStyle: getLineStyle(lineStyle),
                    startLabel: expMatch ? expMatch[1] : null,
                    throughLabel: expMatch ? expMatch[2] : null
                };
            }
            
            // Parse vector
            function parseVector(element, expression) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const color = element.querySelector('objColor');
                const lineStyle = element.querySelector('lineStyle');
                const coords = element.querySelector('coords');
                const startPoint = element.querySelector('startPoint');
                
                return {
                    label: label,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#000000',
                    lineStyle: getLineStyle(lineStyle),
                    dx: coords ? parseFloat(coords.getAttribute('x')) : 0,
                    dy: coords ? parseFloat(coords.getAttribute('y')) : 0,
                    startExp: startPoint ? startPoint.getAttribute('exp') : null
                };
            }
            
            // Parse conic (circle, ellipse, parabola, hyperbola)
            function parseConic(element, expression, type) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const color = element.querySelector('objColor');
                const lineStyle = element.querySelector('lineStyle');
                const matrix = element.querySelector('matrix');
                const eigenvectors = element.querySelector('eigenvectors');
                
                // Conic equation matrix: A0*x^2 + A1*y^2 + A2 + 2*A3*xy + 2*A4*x + 2*A5*y = 0
                // For circle: A0 = A1 = 1, A3 = 0
                // For ellipse: A0, A1 > 0 and different
                // For hyperbola: A0*A1 < 0
                // For parabola: A0 = 0 or A1 = 0
                
                let conicData = {
                    label: label,
                    type: type,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#000000',
                    lineStyle: getLineStyle(lineStyle),
                    matrix: matrix ? {
                        A0: parseFloat(matrix.getAttribute('A0')),
                        A1: parseFloat(matrix.getAttribute('A1')),
                        A2: parseFloat(matrix.getAttribute('A2')),
                        A3: parseFloat(matrix.getAttribute('A3')),
                        A4: parseFloat(matrix.getAttribute('A4')),
                        A5: parseFloat(matrix.getAttribute('A5'))
                    } : null,
                    eigenvectors: eigenvectors ? {
                        x0: parseFloat(eigenvectors.getAttribute('x0')),
                        y0: parseFloat(eigenvectors.getAttribute('y0')),
                        x1: parseFloat(eigenvectors.getAttribute('x1')),
                        y1: parseFloat(eigenvectors.getAttribute('y1'))
                    } : null
                };
                
                // For circle: matrix form is (x-cx)^2 + (y-cy)^2 = r^2
                // Expanded: x^2 + y^2 - 2cx*x - 2cy*y + (cx^2 + cy^2 - r^2) = 0
                // GeoGebra matrix: A0=1, A1=1, A2=cx^2+cy^2-r^2, A3=0, A4=-cx, A5=-cy
                // So: r^2 = cx^2 + cy^2 - A2
                if (type === 'circle' && matrix) {
                    const cx = -parseFloat(matrix.getAttribute('A4'));
                    const cy = -parseFloat(matrix.getAttribute('A5'));
                    const r2 = cx*cx + cy*cy - parseFloat(matrix.getAttribute('A2'));
                    conicData.center = { x: cx, y: cy };
                    conicData.radius = Math.sqrt(Math.abs(r2));
                }
                
                return conicData;
            }
            
            // Parse conic part (arc, sector)
            function parseConicPart(element, expression) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const color = element.querySelector('objColor');
                const lineStyle = element.querySelector('lineStyle');
                const matrix = element.querySelector('matrix');
                const eigenvectors = element.querySelector('eigenvectors');
                
                // Parse arc type and endpoints from expression
                let arcType = 'unknown';
                let endpoints = [];
                
                if (expression) {
                    // Semicircle[A, B]
                    const semicircleMatch = expression.match(/Semicircle\[(\w+),\s*(\w+)\]/);
                    if (semicircleMatch) {
                        arcType = 'semicircle';
                        endpoints = [semicircleMatch[1], semicircleMatch[2]];
                    }
                    
                    // CircumcircleArc[A, B, C] - arc through A centered at circle through A, B, C
                    const circumcircleArcMatch = expression.match(/CircumcircleArc\[(\w+),\s*(\w+),\s*(\w+)\]/);
                    if (circumcircleArcMatch) {
                        arcType = 'circumcircleArc';
                        endpoints = [circumcircleArcMatch[1], circumcircleArcMatch[2], circumcircleArcMatch[3]];
                    }
                    
                    // Arc[center, point1, point2] or CircularArc or CircleArc
                    const arcMatch = expression.match(/(?:Arc|CircularArc|CircleArc)\[(\w+),\s*(\w+),\s*(\w+)\]/);
                    if (arcMatch) {
                        arcType = 'arc';
                        endpoints = [arcMatch[1], arcMatch[2], arcMatch[3]];
                    }
                    
                    // CircleSector[center, point1, point2] or CircularSector
                    const sectorMatch = expression.match(/(?:CircleSector|CircularSector)\[(\w+),\s*(\w+),\s*(\w+)\]/);
                    if (sectorMatch) {
                        arcType = 'sector';
                        endpoints = [sectorMatch[1], sectorMatch[2], sectorMatch[3]];
                    }
                    
                    // CircumcircleSector[A, B, C]
                    const circumcircleSectorMatch = expression.match(/CircumcircleSector\[(\w+),\s*(\w+),\s*(\w+)\]/);
                    if (circumcircleSectorMatch) {
                        arcType = 'circumcircleSector';
                        endpoints = [circumcircleSectorMatch[1], circumcircleSectorMatch[2], circumcircleSectorMatch[3]];
                    }
                }
                
                return {
                    label: label,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#000000',
                    fillOpacity: color ? parseFloat(color.getAttribute('alpha') || '0') : 0,
                    lineStyle: getLineStyle(lineStyle),
                    matrix: matrix ? {
                        A0: parseFloat(matrix.getAttribute('A0')),
                        A1: parseFloat(matrix.getAttribute('A1')),
                        A2: parseFloat(matrix.getAttribute('A2')),
                        A3: parseFloat(matrix.getAttribute('A3')),
                        A4: parseFloat(matrix.getAttribute('A4')),
                        A5: parseFloat(matrix.getAttribute('A5'))
                    } : null,
                    eigenvectors: eigenvectors ? {
                        x0: parseFloat(eigenvectors.getAttribute('x0')),
                        y0: parseFloat(eigenvectors.getAttribute('y0')),
                        x1: parseFloat(eigenvectors.getAttribute('x1')),
                        y1: parseFloat(eigenvectors.getAttribute('y1'))
                    } : null,
                    expression: expression,
                    arcType: arcType,
                    endpoints: endpoints
                };
            }
            
            // Parse polygon
            function parsePolygon(element, expression, polygonCmd) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const color = element.querySelector('objColor');
                const lineStyle = element.querySelector('lineStyle');
                
                // Parse polygon vertices and edges
                let vertices = [];
                let edges = [];
                
                if (polygonCmd) {
                    const inputs = polygonCmd.inputs;
                    const outputs = polygonCmd.outputs;
                    
                    // Check if this is a regular polygon (last input is a number)
                    const lastInput = inputs[inputs.length - 1];
                    const isRegularPolygon = !isNaN(parseInt(lastInput));
                    
                    if (isRegularPolygon) {
                        // Regular polygon: vertices are from inputs (first 2) + outputs (after edges)
                        // inputs[0], inputs[1] are first two vertices
                        // outputs[0] is polygon label
                        // outputs[1] to outputs[n] are edges (n = number of sides)
                        // outputs[n+1] onwards are remaining vertices
                        
                        const numSides = parseInt(lastInput);
                        vertices.push(inputs[0]); // First vertex
                        vertices.push(inputs[1]); // Second vertex
                        
                        // Edges are outputs[1] to outputs[numSides]
                        for (let i = 1; i <= numSides; i++) {
                            if (outputs[i]) {
                                edges.push(outputs[i]);
                            }
                        }
                        
                        // Remaining vertices are outputs[numSides+1] onwards
                        for (let i = numSides + 1; i < outputs.length; i++) {
                            if (outputs[i]) {
                                vertices.push(outputs[i]);
                            }
                        }
                    } else {
                        // Regular polygon defined by vertices: all inputs are vertices
                        // outputs[0] is polygon label, outputs[1] onwards are edges
                        vertices = inputs.slice();
                        
                        for (let i = 1; i < outputs.length; i++) {
                            if (outputs[i]) {
                                edges.push(outputs[i]);
                            }
                        }
                    }
                } else {
                    // Fallback: try to parse from expression
                    if (expression) {
                        const match = expression.match(/Polygon\[(.+)\]/);
                        if (match) {
                            const parts = match[1].split(',').map(v => v.trim());
                            // Check if last part is a number (regular polygon)
                            if (parts.length >= 3 && !isNaN(parseInt(parts[parts.length - 1]))) {
                                // Regular polygon - can't determine all vertices from expression alone
                                // Just use the first two points
                                vertices = parts.slice(0, 2);
                            } else {
                                vertices = parts;
                            }
                        }
                    }
                }
                
                return {
                    label: label,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#1565C0',
                    fillOpacity: color ? parseFloat(color.getAttribute('alpha') || '0') : 0,
                    lineStyle: getLineStyle(lineStyle),
                    vertices: vertices,
                    edges: edges
                };
            }
            
            // Parse function
            function parseFunction(element, expression) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const color = element.querySelector('objColor');
                const lineStyle = element.querySelector('lineStyle');
                
                // Parse function expression - support any function name
                let funcExpr = '';
                let originalExpr = expression || ''; // Store original GGB expression for display
                if (expression) {
                    // Match patterns like: f(x) = sin(x), g(x)=x^2, myFunc(x) = x+1
                    const match = expression.match(/^[a-zA-Z_][a-zA-Z0-9_]*\(x\)\s*=\s*(.+)$/);
                    if (match) {
                        funcExpr = match[1].trim();
                    } else {
                        // Fallback: try to extract after first '='
                        const eqIndex = expression.indexOf('=');
                        if (eqIndex !== -1) {
                            funcExpr = expression.substring(eqIndex + 1).trim();
                        }
                    }
                }
                
                return {
                    label: label,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#006758',
                    lineStyle: getLineStyle(lineStyle),
                    expression: funcExpr,
                    originalExpression: originalExpr // Original GGB expression for display
                };
            }
            
            // Parse angle
            function parseAngle(element, expression) {
                const label = element.getAttribute('label');
                const show = element.querySelector('show');
                const isHidden = show && show.getAttribute('object') === 'false';
                
                const color = element.querySelector('objColor');
                const value = element.querySelector('value');
                
                // Parse angle points from expression
                let points = [];
                if (expression) {
                    const match = expression.match(/Angle\[(\w+),\s*(\w+),\s*(\w+)\]/);
                    if (match) {
                        points = [match[1], match[2], match[3]];
                    }
                }
                
                return {
                    label: label,
                    hidden: isHidden,
                    color: color ? rgbToHex(color.getAttribute('r'), color.getAttribute('g'), color.getAttribute('b')) : '#000000',
                    value: value ? parseFloat(value.getAttribute('val')) : 0,
                    points: points
                };
            }
            
            // Main parsing function
            function parseGeogebraXML(xmlString) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
                
                // Reset parsed elements
                parsedElements = {
                    points: {},
                    segments: [],
                    lines: [],
                    rays: [],
                    vectors: [],
                    circles: [],
                    ellipses: [],
                    parabolas: [],
                    hyperbolas: [],
                    arcs: [],
                    sectors: [],
                    polygons: [],
                    functions: [],
                    angles: [],
                    texts: []
                };
                
                // Parse view settings
                const euclidianView = xmlDoc.querySelector('euclidianView');
                if (euclidianView) {
                    const coordSystem = euclidianView.querySelector('coordSystem');
                    if (coordSystem) {
                        viewSettings.xZero = parseFloat(coordSystem.getAttribute('xZero') || '0');
                        viewSettings.yZero = parseFloat(coordSystem.getAttribute('yZero') || '0');
                        viewSettings.scale = parseFloat(coordSystem.getAttribute('scale') || '1');
                        viewSettings.yscale = parseFloat(coordSystem.getAttribute('yscale') || '1');
                    }
                }
                
                // Build expression map
                const expressions = {};
                xmlDoc.querySelectorAll('expression').forEach(exp => {
                    const label = exp.getAttribute('label');
                    const expStr = exp.getAttribute('exp');
                    if (label && expStr) {
                        expressions[label] = expStr;
                    }
                });
                
                // Parse all elements
                const construction = xmlDoc.querySelector('construction');
                if (construction) {
                    // First pass: collect all points
                    construction.querySelectorAll('element[type="point"]').forEach(elem => {
                        const point = parsePoint(elem);
                        if (point && !point.hidden) {
                            parsedElements.points[point.label] = point;
                        }
                    });
                    
                    // Store polygon command info for later use
                    const polygonCommands = {};
                    
                    // Parse commands for segment/line/ray info
                    construction.querySelectorAll('command').forEach(cmd => {
                        const name = cmd.getAttribute('name');
                        const output = cmd.querySelector('output');
                        if (output) {
                            const outputLabel = output.getAttribute('a0');
                            const inputElems = cmd.querySelectorAll('input');
                            let inputStr = '';
                            let inputs = [];
                            inputElems.forEach(inp => {
                                // Collect all input parameters
                                for (let i = 0; ; i++) {
                                    const attr = inp.getAttribute('a' + i);
                                    if (attr) {
                                        inputs.push(attr);
                                    } else {
                                        break;
                                    }
                                }
                            });
                            if (inputs.length > 0) {
                                inputStr = `${name}[${inputs.join(', ')}]`;
                            }
                            if (outputLabel && inputStr) {
                                expressions[outputLabel] = inputStr;
                            }
                            
                            // For Polygon commands, collect all output info
                            if (name === 'Polygon') {
                                const outputs = [];
                                for (let i = 0; ; i++) {
                                    const attr = output.getAttribute('a' + i);
                                    if (attr) {
                                        outputs.push(attr);
                                    } else {
                                        break;
                                    }
                                }
                                // outputs[0] is polygon label, outputs[1..n] are edges, rest are vertices
                                polygonCommands[outputLabel] = {
                                    inputs: inputs,
                                    outputs: outputs
                                };
                            }
                        }
                    });
                    
                    // Parse expression elements (for functions, etc.)
                    construction.querySelectorAll('expression').forEach(expr => {
                        const label = expr.getAttribute('label');
                        const exp = expr.getAttribute('exp');
                        if (label && exp) {
                            expressions[label] = exp;
                        }
                    });
                    
                    // First pass: process polygons to collect edge labels
                    const polygonEdges = new Set();
                    construction.querySelectorAll('element[type="polygon"]').forEach(elem => {
                        const label = elem.getAttribute('label');
                        const polygonCmd = polygonCommands[label];
                        if (polygonCmd && polygonCmd.outputs) {
                            // outputs[1] onwards are edges (outputs[0] is polygon label)
                            for (let i = 1; i < polygonCmd.outputs.length; i++) {
                                const edgeLabel = polygonCmd.outputs[i];
                                // Check if this looks like an edge (not a point label)
                                // Point labels are typically uppercase letters, edge labels are lowercase or have underscores
                                if (edgeLabel && (edgeLabel.length > 1 || edgeLabel === edgeLabel.toLowerCase())) {
                                    polygonEdges.add(edgeLabel);
                                }
                            }
                        }
                    });
                    
                    // Second pass: parse other elements
                    construction.querySelectorAll('element').forEach(elem => {
                        const type = elem.getAttribute('type');
                        const label = elem.getAttribute('label');
                        const exp = expressions[label] || '';
                        
                        switch(type) {
                            case 'segment':
                                // Skip segments that are edges of a polygon
                                if (polygonEdges.has(label)) {
                                    break;
                                }
                                const segment = parseSegment(elem, exp);
                                if (segment && !segment.hidden) parsedElements.segments.push(segment);
                                break;
                            case 'line':
                                const line = parseLine(elem, exp);
                                if (line && !line.hidden) parsedElements.lines.push(line);
                                break;
                            case 'ray':
                                const ray = parseRay(elem, exp);
                                if (ray && !ray.hidden) parsedElements.rays.push(ray);
                                break;
                            case 'vector':
                                const vector = parseVector(elem, exp);
                                if (vector && !vector.hidden) parsedElements.vectors.push(vector);
                                break;
                            case 'conic':
                                // Determine conic type from expression first, then from matrix
                                const matrix = elem.querySelector('matrix');
                                let conicType = 'ellipse'; // default
                                
                                // Check expression for conic type
                                if (exp) {
                                    if (exp.includes('Circle[') || exp.includes('Circle(')) {
                                        conicType = 'circle';
                                    } else if (exp.includes('Ellipse[')) {
                                        conicType = 'ellipse';
                                    } else if (exp.includes('Hyperbola[')) {
                                        conicType = 'hyperbola';
                                    } else if (exp.includes('Parabola[')) {
                                        conicType = 'parabola';
                                    } else {
                                        // Fallback to matrix-based detection
                                        if (matrix) {
                                            const A0 = parseFloat(matrix.getAttribute('A0'));
                                            const A1 = parseFloat(matrix.getAttribute('A1'));
                                            const A3 = parseFloat(matrix.getAttribute('A3'));
                                            
                                            if (Math.abs(A0 - A1) < 0.001 && Math.abs(A3) < 0.001) {
                                                conicType = 'circle';
                                            } else if (A0 * A1 < 0) {
                                                conicType = 'hyperbola';
                                            } else if (Math.abs(A0) < 0.001 || Math.abs(A1) < 0.001) {
                                                conicType = 'parabola';
                                            }
                                        }
                                    }
                                } else if (matrix) {
                                    // No expression, use matrix
                                    const A0 = parseFloat(matrix.getAttribute('A0'));
                                    const A1 = parseFloat(matrix.getAttribute('A1'));
                                    const A3 = parseFloat(matrix.getAttribute('A3'));
                                    
                                    if (Math.abs(A0 - A1) < 0.001 && Math.abs(A3) < 0.001) {
                                        conicType = 'circle';
                                    } else if (A0 * A1 < 0) {
                                        conicType = 'hyperbola';
                                    } else if (Math.abs(A0) < 0.001 || Math.abs(A1) < 0.001) {
                                        conicType = 'parabola';
                                    }
                                }
                                
                                const conic = parseConic(elem, exp, conicType);
                                if (conic && !conic.hidden) {
                                    switch(conicType) {
                                        case 'circle':
                                            parsedElements.circles.push(conic);
                                            break;
                                        case 'hyperbola':
                                            parsedElements.hyperbolas.push(conic);
                                            break;
                                        case 'parabola':
                                            parsedElements.parabolas.push(conic);
                                            break;
                                        default:
                                            parsedElements.ellipses.push(conic);
                                    }
                                }
                                break;
                            case 'conicpart':
                                const conicPart = parseConicPart(elem, exp);
                                if (conicPart && !conicPart.hidden) {
                                    if (exp.includes('Semicircle') || exp.includes('Arc') || exp.includes('CircumcircleArc')) {
                                        parsedElements.arcs.push(conicPart);
                                    } else {
                                        parsedElements.sectors.push(conicPart);
                                    }
                                }
                                break;
                            case 'polygon':
                                const polygon = parsePolygon(elem, exp, polygonCommands[label]);
                                if (polygon && !polygon.hidden) parsedElements.polygons.push(polygon);
                                break;
                            case 'function':
                                const func = parseFunction(elem, exp);
                                if (func && !func.hidden) parsedElements.functions.push(func);
                                break;
                            case 'angle':
                                const angle = parseAngle(elem, exp);
                                if (angle && !angle.hidden) parsedElements.angles.push(angle);
                                break;
                        }
                    });
                }
                
                return parsedElements;
            }
            
            // Generate TikZ code
            function generateTikZCode() {
                let code = '\\begin{tikzpicture}\n';
                
                // Helper function: Extract conic parameters from matrix
                // Returns { cx, cy, lambda1, lambda2, K, theta, det } for ellipse/hyperbola
                function extractConicParams(matrix, eigenvectors) {
                    const A0 = matrix.A0;
                    const A1 = matrix.A1;
                    const A2 = matrix.A2;
                    const A3 = matrix.A3;
                    const A4 = matrix.A4;
                    const A5 = matrix.A5;
                    
                    // Calculate center: solve [A0 A3; A3 A1] * [cx; cy] = [-A4; -A5]
                    const det = A0 * A1 - A3 * A3;
                    if (Math.abs(det) < 0.0001) return null;
                    
                    const cx = (A3 * A5 - A1 * A4) / det;
                    const cy = (A3 * A4 - A0 * A5) / det;
                    
                    // Calculate eigenvalues
                    const trace = A0 + A1;
                    const disc = Math.sqrt(Math.abs((A0 - A1) * (A0 - A1) + 4 * A3 * A3));
                    const lambda1 = (trace + disc) / 2;
                    const lambda2 = (trace - disc) / 2;
                    
                    // Calculate K (constant term after translation to center)
                    const K = A0 * cx * cx + A1 * cy * cy + A2 + 2 * A3 * cx * cy + 2 * A4 * cx + 2 * A5 * cy;
                    
                    // Rotation angle from eigenvector
                    // The first eigenvector (x0, y0) corresponds to the direction of the first eigenvalue
                    let theta = 0;
                    if (eigenvectors) {
                        theta = Math.atan2(eigenvectors.y0, eigenvectors.x0);
                    } else if (Math.abs(A3) > 0.0001) {
                        // tan(2*theta) = 2*A3 / (A0 - A1)
                        theta = Math.atan2(2 * A3, A0 - A1) / 2;
                    }
                    
                    return { cx, cy, lambda1, lambda2, K, theta, det };
                }
                
                // Add options
                const includeAxes = document.getElementById('includeAxes').checked;
                const includeGrid = document.getElementById('includeGrid').checked;
                
                // Calculate bounds from points
                let allX = [], allY = [];
                Object.values(parsedElements.points).forEach(p => {
                    allX.push(p.x);
                    allY.push(p.y);
                });
                
                let xmin = allX.length ? Math.min(...allX) - 2 : -10;
                let xmax = allX.length ? Math.max(...allX) + 2 : 10;
                let ymin = allY.length ? Math.min(...allY) - 2 : -10;
                let ymax = allY.length ? Math.max(...allY) + 2 : 10;
                
                // Extend bounds to include circles and arcs
                parsedElements.circles.forEach(c => {
                    if (c.center && c.radius) {
                        xmin = Math.min(xmin, c.center.x - c.radius - 1);
                        xmax = Math.max(xmax, c.center.x + c.radius + 1);
                        ymin = Math.min(ymin, c.center.y - c.radius - 1);
                        ymax = Math.max(ymax, c.center.y + c.radius + 1);
                    }
                });
                
                // Extend bounds to include ellipses
                parsedElements.ellipses.forEach(e => {
                    if (e.matrix) {
                        const params = extractConicParams(e.matrix, e.eigenvectors);
                        if (params) {
                            const { cx, cy, lambda1, lambda2, K, theta } = params;
                            const val1 = -K / lambda1;
                            const val2 = -K / lambda2;
                            if (val1 > 0 && val2 > 0) {
                                const a = Math.sqrt(Math.max(val1, val2));
                                const b = Math.sqrt(Math.min(val1, val2));
                                // Ellipse extends approximately a*|cosT| + b*|sinT| in x direction
                                // and a*|sinT| + b*|cosT| in y direction (worst case)
                                const cosT = Math.abs(Math.cos(theta));
                                const sinT = Math.abs(Math.sin(theta));
                                const xExtent = a * cosT + b * sinT;
                                const yExtent = a * sinT + b * cosT;
                                xmin = Math.min(xmin, cx - xExtent - 1);
                                xmax = Math.max(xmax, cx + xExtent + 1);
                                ymin = Math.min(ymin, cy - yExtent - 1);
                                ymax = Math.max(ymax, cy + yExtent + 1);
                            }
                        }
                    }
                });
                
                // Extend bounds to include hyperbolas
                parsedElements.hyperbolas.forEach(h => {
                    if (h.matrix) {
                        const params = extractConicParams(h.matrix, h.eigenvectors);
                        if (params) {
                            const { cx, cy, lambda1, lambda2, K, theta } = params;
                            const val1 = -K / lambda1;
                            const val2 = -K / lambda2;
                            // For hyperbola, one value is positive (a^2), one is negative (-b^2)
                            let a, b;
                            if (val1 > 0 && val2 < 0) {
                                a = Math.sqrt(val1);
                                b = Math.sqrt(-val2);
                            } else if (val2 > 0 && val1 < 0) {
                                a = Math.sqrt(val2);
                                b = Math.sqrt(-val1);
                            } else {
                                return;
                            }
                            // Hyperbola branches extend infinitely, but we estimate visible range
                            // Use the center plus some extent based on hyperbola shape
                            const extent = Math.max(a, b) * 3;
                            xmin = Math.min(xmin, cx - extent - 1);
                            xmax = Math.max(xmax, cx + extent + 1);
                            ymin = Math.min(ymin, cy - extent - 1);
                            ymax = Math.max(ymax, cy + extent + 1);
                        }
                    }
                });
                
                // Extend bounds to include parabolas
                parsedElements.parabolas.forEach(p => {
                    if (p.matrix) {
                        const A0 = p.matrix.A0;
                        const A1 = p.matrix.A1;
                        const A4 = p.matrix.A4;
                        const A5 = p.matrix.A5;
                        // Estimate parabola vertex
                        let vx = 0, vy = 0;
                        if (Math.abs(A1) < 0.001 && Math.abs(A0) > 0.001) {
                            vx = -A4 / A0;
                            vy = 0;
                        } else if (Math.abs(A0) < 0.001 && Math.abs(A1) > 0.001) {
                            vy = -A5 / A1;
                            vx = 0;
                        }
                        // Parabola extends in one direction, estimate visible range
                        xmin = Math.min(xmin, vx - 5);
                        xmax = Math.max(xmax, vx + 5);
                        ymin = Math.min(ymin, vy - 5);
                        ymax = Math.max(ymax, vy + 5);
                    }
                });
                
                // Get clip/bbox range if enabled
                const enableClipRange = document.getElementById('enableClipRange');
                let bboxXmin = xmin, bboxXmax = xmax, bboxYmin = ymin, bboxYmax = ymax;
                if (enableClipRange && enableClipRange.checked) {
                    // Use isNaN check instead of || to handle 0 correctly
                    const parsedXmin = parseFloat(document.getElementById('clipXmin').value);
                    const parsedXmax = parseFloat(document.getElementById('clipXmax').value);
                    const parsedYmin = parseFloat(document.getElementById('clipYmin').value);
                    const parsedYmax = parseFloat(document.getElementById('clipYmax').value);
                    bboxXmin = isNaN(parsedXmin) ? -10 : parsedXmin;
                    bboxXmax = isNaN(parsedXmax) ? 10 : parsedXmax;
                    bboxYmin = isNaN(parsedYmin) ? -10 : parsedYmin;
                    bboxYmax = isNaN(parsedYmax) ? 10 : parsedYmax;
                    // Also update xmin/xmax for line/ray calculations
                    xmin = bboxXmin;
                    xmax = bboxXmax;
                    ymin = bboxYmin;
                    ymax = bboxYmax;
                }
                
                // Set bounding box to prevent "Dimension too large" errors
                const bboxPadding = 1;
                code += `\\useasboundingbox (${roundNum(bboxXmin - bboxPadding)}, ${roundNum(bboxYmin - bboxPadding)}) rectangle (${roundNum(bboxXmax + bboxPadding)}, ${roundNum(bboxYmax + bboxPadding)});\n`;
                
                // Collect all colors and create mapping
                let colorSet = new Set();
                Object.values(parsedElements.points).forEach(p => colorSet.add(p.color));
                parsedElements.segments.forEach(s => colorSet.add(s.color));
                parsedElements.lines.forEach(l => colorSet.add(l.color));
                parsedElements.rays.forEach(r => colorSet.add(r.color));
                parsedElements.vectors.forEach(v => colorSet.add(v.color));
                parsedElements.circles.forEach(c => colorSet.add(c.color));
                parsedElements.ellipses.forEach(e => colorSet.add(e.color));
                parsedElements.arcs.forEach(a => colorSet.add(a.color));
                parsedElements.polygons.forEach(p => colorSet.add(p.color));
                parsedElements.angles.forEach(a => colorSet.add(a.color));
                
                // Create color name mapping
                let colorMap = {};
                colorMap['#000000'] = 'black';
                let colorIdx = 0;
                colorSet.forEach(c => {
                    if (c !== '#000000' && !colorMap[c]) {
                        colorMap[c] = `ggbcolor${colorIdx}`;
                        colorIdx++;
                    }
                });
                
                // Define colors (skip in black & white mode)
                const isBlackAndWhite = document.getElementById('blackAndWhite').checked;
                if (colorIdx > 0 && !isBlackAndWhite) {
                    code += '% Colors\n';
                    Object.keys(colorMap).forEach(c => {
                        if (c !== '#000000') {
                            code += `\\definecolor{${colorMap[c]}}{HTML}{${c.substring(1)}}\n`;
                        }
                    });
                    code += '\n';
                }
                
                // Add clip for conic curves if enabled (bbox already set above)
                const hasConics = parsedElements.ellipses.length > 0 || 
                                  parsedElements.hyperbolas.length > 0 || 
                                  parsedElements.parabolas.length > 0;
                if (enableClipRange && enableClipRange.checked && hasConics) {
                    code += `% Clip range for conics\n`;
                    code += `\\clip (${bboxXmin}, ${bboxYmin}) rectangle (${bboxXmax}, ${bboxYmax});\n\n`;
                }
                
                // Draw grid if enabled (before other elements, as background)
                if (includeGrid) {
                    code += `% Grid\n`;
                    code += `\\draw[gray!30, very thin, step=1] (${roundNum(bboxXmin)}, ${roundNum(bboxYmin)}) grid (${roundNum(bboxXmax)}, ${roundNum(bboxYmax)});\n`;
                }
                
                // Draw axes if enabled
                if (includeAxes) {
                    code += `% Axes\n`;
                    // X-axis
                    code += `\\draw[->, thick] (${roundNum(bboxXmin)}, 0) -- (${roundNum(bboxXmax)}, 0) node[right] {$x$};\n`;
                    // Y-axis
                    code += `\\draw[->, thick] (0, ${roundNum(bboxYmin)}) -- (0, ${roundNum(bboxYmax)}) node[above] {$y$};\n`;
                    // Tick marks and labels
                    for (let x = Math.ceil(bboxXmin); x <= Math.floor(bboxXmax); x++) {
                        if (x !== 0) {
                            code += `\\draw (${x}, -0.1) -- (${x}, 0.1);\n`;
                            if (x % 2 === 0 || Math.abs(x) <= 5) {
                                code += `\\node[below] at (${x}, -0.1) {${x}};\n`;
                            }
                        }
                    }
                    for (let y = Math.ceil(bboxYmin); y <= Math.floor(bboxYmax); y++) {
                        if (y !== 0) {
                            code += `\\draw (-0.1, ${y}) -- (0.1, ${y});\n`;
                            if (y % 2 === 0 || Math.abs(y) <= 5) {
                                code += `\\node[left] at (-0.1, ${y}) {${y}};\n`;
                            }
                        }
                    }
                    // Origin label
                    code += `\\node[below left] at (0, 0) {$O$};\n`;
                }
                
                // Helper function to get TikZ color name
                function getTikZColor(hexColor) {
                    // Black and white mode: always return black
                    if (document.getElementById('blackAndWhite').checked) {
                        return 'black';
                    }
                    if (hexColor === '#000000' || hexColor === 'black') return 'black';
                    return colorMap[hexColor] || 'black';
                }
                
                const includePoints = document.getElementById('includePoints').checked;
                const includeLabels = document.getElementById('includeLabels').checked;
                
                // Draw polygons first (background)
                parsedElements.polygons.forEach(poly => {
                    if (poly.vertices.length > 0) {
                        const pts = poly.vertices.map(v => {
                            const p = parsedElements.points[v];
                            return p ? `(${roundNum(p.x)}, ${roundNum(p.y)})` : null;
                        }).filter(p => p !== null);
                        
                        if (pts.length >= 3) {
                            const polyColor = getTikZColor(poly.color);
                            code += `\\fill[${polyColor}, fill opacity=0.1] ${pts.join(' -- ')} -- cycle;\n`;
                            code += `\\draw[${poly.lineStyle}, ${polyColor}] ${pts.join(' -- ')} -- cycle;\n`;
                        }
                    }
                });
                
                // Draw circles
                parsedElements.circles.forEach(circle => {
                    if (circle.center && circle.radius) {
                        const circleColor = getTikZColor(circle.color);
                        code += `\\draw[${circle.lineStyle}, ${circleColor}] (${roundNum(circle.center.x)}, ${roundNum(circle.center.y)}) circle (${roundNum(circle.radius)});\n`;
                    }
                });
                
                // Draw ellipses using parametric plot
                parsedElements.ellipses.forEach(ellipse => {
                    if (ellipse.matrix) {
                        const ellipseColor = getTikZColor(ellipse.color);
                        const A0 = ellipse.matrix.A0;
                        const A1 = ellipse.matrix.A1;
                        const A3 = ellipse.matrix.A3;
                        
                        // When A3 = 0 (no rotation in matrix), the eigenvectors directly correspond to matrix elements:
                        // - eigenvector(x0, y0) corresponds to eigenvalue A0
                        // - eigenvector(x1, y1) corresponds to eigenvalue A1
                        // When A3 ‚â† 0, we need to use the eigenvalue/eigenvector calculation
                        
                        const params = extractConicParams(ellipse.matrix, ellipse.eigenvectors);
                        
                        if (params && Math.abs(params.K) > 0.0001) {
                            const { cx, cy, K, theta } = params;
                            
                            // For ellipse: eigenvalues are both positive
                            // Semi-axis along eigenvector direction = sqrt(-K/eigenvalue)
                            // Larger eigenvalue ‚Üí smaller semi-axis (shorter)
                            // Smaller eigenvalue ‚Üí larger semi-axis (longer)
                            
                            // GeoGebra's eigenvector(x0, y0) points in a specific direction
                            // The semi-axis along this direction has length sqrt(-K/eigenvalue_at_this_direction)
                            
                            // When A3 ‚âà 0 (no cross term):
                            // - eigenvector(x0, y0) = (1, 0) or (0, 1) depending on which eigenvalue is smaller
                            // - Actually, from GeoGebra XML: eigenvector(x0, y0) corresponds to A0 when A3=0
                            // - So eigenvector(x0, y0) direction has semi-axis = sqrt(-K/A0)
                            // - eigenvector(x1, y1) direction has semi-axis = sqrt(-K/A1)
                            
                            let a, b, longAxisTheta;
                            
                            if (Math.abs(A3) < 0.001) {
                                // No rotation case - eigenvectors align with coordinate axes
                                // eigenvector(x0, y0) = (1, 0) means it points along x-axis
                                // This direction corresponds to eigenvalue A0
                                const semiAxis0 = Math.sqrt(Math.abs(-K / A0));  // along eigenvector(x0, y0) direction
                                const semiAxis1 = Math.sqrt(Math.abs(-K / A1));  // along eigenvector(x1, y1) direction
                                
                                // theta from eigenvector(x0, y0) = atan2(y0, x0)
                                // For A3=0: theta = 0 if eigenvector(x0,y0)=(1,0), or PI/2 if eigenvector(x0,y0)=(0,1)
                                // theta gives the direction of eigenvector(x0, y0)
                                
                                // Determine which is longer
                                if (semiAxis0 >= semiAxis1) {
                                    a = semiAxis0;  // long axis
                                    b = semiAxis1;  // short axis
                                    longAxisTheta = theta;  // eigenvector(x0, y0) direction
                                } else {
                                    a = semiAxis1;  // long axis
                                    b = semiAxis0;  // short axis
                                    longAxisTheta = theta + Math.PI / 2;  // perpendicular to eigenvector(x0, y0)
                                }
                            } else {
                                // Rotated case - use eigenvalues from extractConicParams
                                // IMPORTANT: GeoGebra's eigenvector(x0, y0) corresponds to lambda2 (smaller eigenvalue)
                                // Smaller eigenvalue ‚Üí larger val ‚Üí longer semi-axis
                                // So theta direction (eigenvector x0, y0) has semi-axis sqrt(val2)
                                const { lambda1, lambda2 } = params;
                                const val1 = -K / lambda1;
                                const val2 = -K / lambda2;
                                
                                if (val1 > 0 && val2 > 0) {
                                    // theta direction corresponds to eigenvector(x0, y0) ‚Üí lambda2 ‚Üí val2
                                    const semiAxisAlongTheta = Math.sqrt(val2);
                                    const semiAxisPerpTheta = Math.sqrt(val1);
                                    
                                    // Determine which is the long axis
                                    if (semiAxisAlongTheta >= semiAxisPerpTheta) {
                                        a = semiAxisAlongTheta;  // long axis
                                        b = semiAxisPerpTheta;   // short axis
                                        longAxisTheta = theta;
                                    } else {
                                        a = semiAxisPerpTheta;   // long axis
                                        b = semiAxisAlongTheta;  // short axis
                                        longAxisTheta = theta + Math.PI / 2;
                                    }
                                } else {
                                    return; // Invalid ellipse
                                }
                            }
                            
                            // Standard parametric form (long axis along x, then rotate):
                            // x = cx + a*cos(t)*cos(longAxisTheta) - b*sin(t)*sin(longAxisTheta)
                            // y = cy + a*cos(t)*sin(longAxisTheta) + b*sin(t)*cos(longAxisTheta)
                            
                            const cosT = Math.cos(longAxisTheta);
                            const sinT = Math.sin(longAxisTheta);
                            
                            if (isFinite(a) && isFinite(b) && a > 0 && b > 0 && 
                                isFinite(cosT) && isFinite(sinT)) {
                                code += `% Ellipse ${ellipse.label}\n`;
                                const xCoef1 = roundNum(a * cosT);
                                const xCoef2 = roundNum(b * sinT);
                                const yCoef1 = roundNum(a * sinT);
                                const yCoef2 = roundNum(b * cosT);
                                
                                // Build x expression, skipping near-zero coefficients
                                let xExpr = `${roundNum(cx)}`;
                                if (Math.abs(xCoef1) > 0.001) {
                                    xExpr += xCoef1 >= 0 ? `+${xCoef1}*cos(\\x)` : `${xCoef1}*cos(\\x)`;
                                }
                                if (Math.abs(xCoef2) > 0.001) {
                                    xExpr += xCoef2 >= 0 ? `-${xCoef2}*sin(\\x)` : `+${Math.abs(xCoef2)}*sin(\\x)`;
                                }
                                
                                // Build y expression, skipping near-zero coefficients
                                let yExpr = `${roundNum(cy)}`;
                                if (Math.abs(yCoef1) > 0.001) {
                                    yExpr += yCoef1 >= 0 ? `+${yCoef1}*cos(\\x)` : `${yCoef1}*cos(\\x)`;
                                }
                                if (Math.abs(yCoef2) > 0.001) {
                                    yExpr += yCoef2 >= 0 ? `+${yCoef2}*sin(\\x)` : `-${Math.abs(yCoef2)}*sin(\\x)`;
                                }
                                
                                code += `\\draw[${ellipse.lineStyle}, ${ellipseColor}, trig format=rad] plot[smooth, domain=0:6.28319, samples=100] ({${xExpr}}, {${yExpr}});\n`;
                            }
                        }
                    }
                });
                
                // Helper function to convert GeoGebra expression to TikZ
                function convertGGBExprToTikZ(expr) {
                    if (!expr) return '';
                    let tikzExpr = expr;
                    
                    // Convert function names (add 'r' for radians in trig functions)
                    tikzExpr = tikzExpr.replace(/\bsin\s*\(/g, 'sin(');
                    tikzExpr = tikzExpr.replace(/\bcos\s*\(/g, 'cos(');
                    tikzExpr = tikzExpr.replace(/\btan\s*\(/g, 'tan(');
                    tikzExpr = tikzExpr.replace(/\bcot\s*\(/g, 'cot(');
                    tikzExpr = tikzExpr.replace(/\basin\s*\(/g, 'asin(');
                    tikzExpr = tikzExpr.replace(/\bacos\s*\(/g, 'acos(');
                    tikzExpr = tikzExpr.replace(/\batan\s*\(/g, 'atan(');
                    
                    // Convert variable x to \x (but not in function names)
                    tikzExpr = tikzExpr.replace(/\bx\b/g, '\\x');
                    
                    // Add 'r' after x in trig functions for radian mode
                    // sin(\x) -> sin(\x r), cos(\x) -> cos(\x r), etc.
                    tikzExpr = tikzExpr.replace(/(sin|cos|tan|cot|asin|acos|atan)\(\\x([^r])/g, '$1(\\x r$2');
                    tikzExpr = tikzExpr.replace(/(sin|cos|tan|cot|asin|acos|atan)\(\\x\)/g, '$1(\\x r)');
                    
                    // Handle exp(x) -> exp(\x)
                    tikzExpr = tikzExpr.replace(/\bexp\s*\(/g, 'exp(');
                    
                    // Handle ln, log, sqrt, abs
                    tikzExpr = tikzExpr.replace(/\bln\s*\(/g, 'ln(');
                    tikzExpr = tikzExpr.replace(/\blog\s*\(/g, 'log10(');
                    tikzExpr = tikzExpr.replace(/\bsqrt\s*\(/g, 'sqrt(');
                    tikzExpr = tikzExpr.replace(/\babs\s*\(/g, 'abs(');
                    
                    // Handle nested x in these functions
                    tikzExpr = tikzExpr.replace(/(ln|log10|sqrt|abs|exp)\(\\x\)/g, '$1(\\x)');
                    
                    return tikzExpr;
                }
                
                // Draw parabolas
                // Parabola equation: A0*x^2 + A1*y^2 + 2*A3*xy + 2*A4*x + 2*A5*y + A2 = 0
                // For parabola, one of A0 or A1 is zero (or near zero)
                parsedElements.parabolas.forEach(parabola => {
                    if (parabola.matrix) {
                        const parabolaColor = getTikZColor(parabola.color);
                        const A0 = parabola.matrix.A0;
                        const A1 = parabola.matrix.A1;
                        const A2 = parabola.matrix.A2;
                        const A3 = parabola.matrix.A3;
                        const A4 = parabola.matrix.A4;
                        const A5 = parabola.matrix.A5;
                        
                        // Get rotation from eigenvector
                        let theta = 0;
                        if (parabola.eigenvectors) {
                            // Eigenvector direction gives axis direction
                            theta = Math.atan2(parabola.eigenvectors.y0, parabola.eigenvectors.x0);
                        }
                        
                        // For parabola: one coefficient is zero
                        // Case 1: A1 = 0 (parabola opens along y-axis direction)
                        // Case 2: A0 = 0 (parabola opens along x-axis direction)
                        
                        let vertexX, vertexY, p; // p is focal parameter (distance from vertex to focus)
                        
                        if (Math.abs(A1) < 0.001) {
                            // Form: A0*x^2 + 2*A3*xy + 2*A4*x + 2*A5*y + A2 = 0
                            // Simplified: A0*x^2 + 2*A4*x + 2*A5*y + A2 = 0 (when A3=0)
                            // => y = -A0/(2*A5) * x^2 - A4/A5 * x - A2/(2*A5)
                            // Vertex x = -A4/A0, y = (A4^2 - A0*A2) / (2*A0*A5)
                            // But we need to account for rotation
                            
                            // Use eigenvector-based approach
                            // The axis direction is perpendicular to the directrix
                            const cosT = Math.cos(theta);
                            const sinT = Math.sin(theta);
                            
                            // Transform to rotated coordinate system
                            // The parabola in its local coordinates: y = x^2/(4p)
                            // We need to find vertex in world coordinates
                            
                            // For standard form x^2 = 4p*y (opening up) rotated by theta
                            // Vertex is at intersection of axis with parabola
                            // From matrix: solve for vertex using calculus
                            
                            // The vertex satisfies: gradient = 0 for the axis direction
                            // Partial derivatives: d/dx and d/dy of the implicit equation
                            // 2*A0*x + 2*A3*y + 2*A4 = 0 ... (1)
                            // 2*A3*x + 2*A1*y + 2*A5 = 0 ... (2) but A1=0
                            // From (1): x = -(A3*y + A4)/A0
                            // The vertex is on the axis, so we need another condition
                            
                            // Alternative: use the formula for parabola vertex
                            // For rotated parabola, vertex can be found by:
                            // The axis passes through the focus and vertex
                            // Directrix is perpendicular to axis
                            
                            // Simplified approach using GGB's implicit data
                            // If A1=0 and A3=0: y = -(A0*x^2 + 2*A4*x + A2)/(2*A5)
                            if (Math.abs(A3) < 0.001) {
                                vertexX = -A4 / A0;
                                vertexY = -(A0 * vertexX * vertexX + 2 * A4 * vertexX + A2) / (2 * A5);
                                // p = 1/(4|coeff|) where coeff is coefficient of x^2 after completing square
                                p = Math.abs(A5 / (2 * A0));
                            } else {
                                // Rotated case: use the focus-directrix property
                                // Distance from vertex to focus = |p| where p is focal parameter
                                // For now, estimate from matrix coefficients
                                p = Math.abs(1 / (2 * Math.sqrt(A0 * A0 + A3 * A3)));
                                vertexX = 0;
                                vertexY = 0;
                            }
                        } else if (Math.abs(A0) < 0.001) {
                            // Form: A1*y^2 + 2*A3*xy + 2*A4*x + 2*A5*y + A2 = 0
                            // Similar logic, parabola opens along x direction
                            if (Math.abs(A3) < 0.001) {
                                vertexY = -A5 / A1;
                                vertexX = -(A1 * vertexY * vertexY + 2 * A5 * vertexY + A2) / (2 * A4);
                                p = Math.abs(A4 / (2 * A1));
                            } else {
                                p = Math.abs(1 / (2 * Math.sqrt(A1 * A1 + A3 * A3)));
                                vertexX = 0;
                                vertexY = 0;
                            }
                        } else {
                            // Neither is zero, use general approach
                            p = 1;
                            vertexX = 0;
                            vertexY = 0;
                        }
                        
                        if (isFinite(p) && p > 0) {
                            code += `% Parabola ${parabola.label}\n`;
                            const cosT = Math.cos(theta);
                            const sinT = Math.sin(theta);
                            
                            // GeoGebra's eigenvector(x0, y0) points to the SYMMETRIC AXIS direction
                            // For parabola with symmetric axis along theta:
                            // - symmetric axis direction: (cosT, sinT)
                            // - opening direction: (sinT, -cosT) [perpendicular, rotated 90¬∞ clockwise]
                            // - the "opening" direction is where the parabola curves toward
                            
                            // Parametric form (opening perpendicular to symmetric axis):
                            // x = vertexX + t*sinT + (t^2/(4p))*cosT
                            // y = vertexY - t*cosT + (t^2/(4p))*sinT
                            // This gives opening in direction (cosT, sinT) i.e. along symmetric axis
                            
                            // Determine if parabola opens in opposite direction
                            const opensNegative = (Math.abs(A1) < 0.001 && A5 < 0) || 
                                                  (Math.abs(A0) < 0.001 && A4 < 0);
                            const sign = opensNegative ? 1 : -1;  // Note: flipped sign
                            
                            // Use larger extent for the plot - consider all bbox boundaries
                            const maxDist = Math.max(
                                Math.abs(bboxXmax - vertexX), Math.abs(bboxXmin - vertexX),
                                Math.abs(bboxYmax - vertexY), Math.abs(bboxYmin - vertexY)
                            );
                            const tExtent = Math.max(5, Math.sqrt(4 * p * maxDist));
                            const tMax = Math.min(tExtent, 15);
                            
                            // Pre-calculate coefficients
                            // x = vertexX + t*sinT + sign*(t^2/(4p))*cosT
                            // y = vertexY - t*cosT + sign*(t^2/(4p))*sinT
                            const xCoef1 = roundNum(sinT);
                            const xCoef2 = roundNum(sign * cosT / (4 * p));
                            const yCoef1 = roundNum(-cosT);
                            const yCoef2 = roundNum(sign * sinT / (4 * p));
                            
                            // Build x expression, skipping near-zero coefficients
                            let xExpr = `${roundNum(vertexX)}`;
                            if (Math.abs(xCoef1) > 0.001) {
                                xExpr += xCoef1 >= 0 ? `+${xCoef1}*\\x` : `${xCoef1}*\\x`;
                            }
                            if (Math.abs(xCoef2) > 0.001) {
                                xExpr += xCoef2 >= 0 ? `+${xCoef2}*\\x*\\x` : `${xCoef2}*\\x*\\x`;
                            }
                            
                            // Build y expression, skipping near-zero coefficients
                            let yExpr = `${roundNum(vertexY)}`;
                            if (Math.abs(yCoef1) > 0.001) {
                                yExpr += yCoef1 >= 0 ? `+${yCoef1}*\\x` : `${yCoef1}*\\x`;
                            }
                            if (Math.abs(yCoef2) > 0.001) {
                                yExpr += yCoef2 >= 0 ? `+${yCoef2}*\\x*\\x` : `${yCoef2}*\\x*\\x`;
                            }
                            
                            code += `\\draw[${parabola.lineStyle}, ${parabolaColor}, domain=-${roundNum(tMax)}:${roundNum(tMax)}, samples=100] plot ({${xExpr}}, {${yExpr}});\n`;
                        }
                    }
                });
                
                // Draw hyperbolas
                // Hyperbola equation: A0*x^2 + A1*y^2 + 2*A3*xy + 2*A4*x + 2*A5*y + A2 = 0
                // For hyperbola: A0*A1 < 0 (opposite signs)
                parsedElements.hyperbolas.forEach(hyperbola => {
                    if (hyperbola.matrix) {
                        const hyperbolaColor = getTikZColor(hyperbola.color);
                        const params = extractConicParams(hyperbola.matrix, hyperbola.eigenvectors);
                        
                        if (params && Math.abs(params.K) > 0.0001) {
                            const { cx, cy, lambda1, lambda2, K, theta } = params;
                            
                            // For hyperbola: eigenvalues have opposite signs
                            // val1 = -K/lambda1, val2 = -K/lambda2
                            // One is positive (a^2, real axis), one is negative (-b^2, imaginary axis)
                            const val1 = -K / lambda1;
                            const val2 = -K / lambda2;
                            
                            // GeoGebra's eigenvector(x0, y0) corresponds to lambda2 (smaller eigenvalue)
                            // For hyperbola with K > 0:
                            // - lambda2 < 0 (negative eigenvalue) ‚Üí val2 > 0 ‚Üí real axis
                            // - lambda1 > 0 (positive eigenvalue) ‚Üí val1 < 0 ‚Üí imaginary axis
                            // So the real axis direction is eigenvector(x0, y0), i.e., theta
                            let a, b, realAxisTheta;
                            
                            if (val2 > 0 && val1 < 0) {
                                // Real axis along eigenvector(x0, y0), at angle theta
                                a = Math.sqrt(val2);
                                b = Math.sqrt(-val1);
                                realAxisTheta = theta;
                            } else if (val1 > 0 && val2 < 0) {
                                // Real axis along eigenvector(x1, y1), at angle theta + PI/2
                                a = Math.sqrt(val1);
                                b = Math.sqrt(-val2);
                                realAxisTheta = theta + Math.PI / 2;
                            } else {
                                // Degenerate or error case
                                return;
                            }
                            
                            // If the real axis points toward negative x direction, flip it by PI
                            // This ensures "right branch" goes toward +x direction
                            if (Math.cos(realAxisTheta) < 0) {
                                realAxisTheta += Math.PI;
                            }
                            
                            // Normalize realAxisTheta to [-PI, PI]
                            while (realAxisTheta > Math.PI) realAxisTheta -= 2 * Math.PI;
                            while (realAxisTheta < -Math.PI) realAxisTheta += 2 * Math.PI;
                            
                            const cosT = Math.cos(realAxisTheta);
                            const sinT = Math.sin(realAxisTheta);
                            
                            if (isFinite(a) && isFinite(b) && a > 0 && b > 0 && 
                                isFinite(cosT) && isFinite(sinT)) {
                                code += `% Hyperbola ${hyperbola.label}\n`;
                                
                                // Parametric form for hyperbola:
                                // In local coords (real axis along x): x = a*cosh(t), y = b*sinh(t)
                                // After rotation by realAxisTheta:
                                // x = cx + a*cosh(t)*cos(realAxisTheta) - b*sinh(t)*sin(realAxisTheta)
                                // y = cy + a*cosh(t)*sin(realAxisTheta) + b*sinh(t)*cos(realAxisTheta)
                                
                                // Calculate tmax based on the distance from center to bbox boundaries
                                // The hyperbola extends approximately a*cosh(t) in the real axis direction
                                // We want it to reach at least to the bbox boundaries
                                const distToBbox = Math.max(
                                    Math.abs(cx - bboxXmin), Math.abs(cx - bboxXmax),
                                    Math.abs(cy - bboxYmin), Math.abs(cy - bboxYmax)
                                );
                                // cosh(t) ‚âà e^t/2 for large t, so t ‚âà ln(2*dist/a)
                                const tmax = Math.min(Math.max(2.5, Math.log(Math.max(1, 2 * distToBbox / Math.max(a, 0.1)))), 5);
                                
                                const aCosT = a * cosT;
                                const bSinT = b * sinT;
                                const aSinT = a * sinT;
                                const bCosT = b * cosT;
                                
                                const cxStr = roundNum(cx);
                                const cyStr = roundNum(cy);
                                
                                // Build expressions dynamically, skipping near-zero coefficients
                                function buildHyperbolaExpr(centerX, centerY, aCosT, bSinT, aSinT, bCosT, branch) {
                                    const mult = branch === 'right' ? 1 : -1;
                                    
                                    let xExpr = `${centerX}`;
                                    if (Math.abs(aCosT) > 0.001) {
                                        const val = roundNum(Math.abs(aCosT));
                                        const sign = (mult * aCosT) >= 0 ? '+' : '-';
                                        xExpr += `${sign}${val}*cosh(\\x)`;
                                    }
                                    if (Math.abs(bSinT) > 0.001) {
                                        const val = roundNum(Math.abs(bSinT));
                                        const sign = (-bSinT) >= 0 ? '+' : '-';
                                        xExpr += `${sign}${val}*sinh(\\x)`;
                                    }
                                    
                                    let yExpr = `${centerY}`;
                                    if (Math.abs(aSinT) > 0.001) {
                                        const val = roundNum(Math.abs(aSinT));
                                        const sign = (mult * aSinT) >= 0 ? '+' : '-';
                                        yExpr += `${sign}${val}*cosh(\\x)`;
                                    }
                                    if (Math.abs(bCosT) > 0.001) {
                                        const val = roundNum(Math.abs(bCosT));
                                        const sign = (bCosT) >= 0 ? '+' : '-';
                                        yExpr += `${sign}${val}*sinh(\\x)`;
                                    }
                                    
                                    return { xExpr, yExpr };
                                }
                                
                                // Right branch (+a direction, toward +x)
                                const rightExpr = buildHyperbolaExpr(cxStr, cyStr, aCosT, bSinT, aSinT, bCosT, 'right');
                                code += `\\draw[${hyperbola.lineStyle}, ${hyperbolaColor}] plot[smooth, domain=-${tmax}:${tmax}, samples=100] ({${rightExpr.xExpr}}, {${rightExpr.yExpr}});\n`;
                                
                                // Left branch (-a direction)
                                const leftExpr = buildHyperbolaExpr(cxStr, cyStr, aCosT, bSinT, aSinT, bCosT, 'left');
                                code += `\\draw[${hyperbola.lineStyle}, ${hyperbolaColor}] plot[smooth, domain=-${tmax}:${tmax}, samples=100] ({${leftExpr.xExpr}}, {${leftExpr.yExpr}});\n`;
                            }
                        }
                    }
                });
                
                // Draw functions
                parsedElements.functions.forEach(func => {
                    if (func.expression) {
                        const funcColor = getTikZColor(func.color);
                        const tikzExpr = convertGGBExprToTikZ(func.expression);
                        
                        // Parse user-specified ranges from functionRanges
                        // Format: "min1,max1+min2,max2+..." or empty for default
                        const rangeStr = functionRanges[func.label] || '';
                        let ranges = [];
                        
                        if (rangeStr.trim()) {
                            // Parse user-specified ranges
                            const rangeParts = rangeStr.split('+');
                            for (const part of rangeParts) {
                                const trimmed = part.trim();
                                const match = trimmed.match(/^(-?[\d.]+)\s*,\s*(-?[\d.]+)$/);
                                if (match) {
                                    const min = parseFloat(match[1]);
                                    const max = parseFloat(match[2]);
                                    if (!isNaN(min) && !isNaN(max) && min < max) {
                                        ranges.push({ min, max });
                                    }
                                }
                            }
                        }
                        
                        // If no valid ranges specified, use default bounds
                        if (ranges.length === 0) {
                            ranges.push({ min: bboxXmin, max: bboxXmax });
                        }
                        
                        code += `% Function ${func.label}\n`;
                        
                        // Check if function has potential discontinuities
                        const hasDiscontinuity = tikzExpr.includes('/\\x') || tikzExpr.includes('/ \\x');
                        
                        // Draw for each range
                        ranges.forEach((range, idx) => {
                            if (hasDiscontinuity) {
                                // Check if range includes x=0
                                if (range.min <= 0 && range.max >= 0) {
                                    // Split at x=0
                                    if (range.min < 0) {
                                        code += `\\draw[${func.lineStyle}, ${funcColor}, domain=${roundNum(range.min)}:-0.001, samples=100] plot (\\x, {${tikzExpr}});\n`;
                                    }
                                    if (range.max > 0) {
                                        code += `\\draw[${func.lineStyle}, ${funcColor}, domain=0.001:${roundNum(range.max)}, samples=100] plot (\\x, {${tikzExpr}});\n`;
                                    }
                                } else {
                                    code += `\\draw[${func.lineStyle}, ${funcColor}, domain=${roundNum(range.min)}:${roundNum(range.max)}, samples=100] plot (\\x, {${tikzExpr}});\n`;
                                }
                            } else {
                                const samples = Math.min(200, Math.max(50, Math.round((range.max - range.min) * 20)));
                                code += `\\draw[${func.lineStyle}, ${funcColor}, domain=${roundNum(range.min)}:${roundNum(range.max)}, samples=${samples}] plot (\\x, {${tikzExpr}});\n`;
                            }
                        });
                    }
                });
                
                // Draw segments
                parsedElements.segments.forEach(seg => {
                    if (seg.startLabel && seg.endLabel) {
                        const start = parsedElements.points[seg.startLabel];
                        const end = parsedElements.points[seg.endLabel];
                        if (start && end) {
                            const segColor = getTikZColor(seg.color);
                            code += `\\draw[${seg.lineStyle}, ${segColor}] (${roundNum(start.x)}, ${roundNum(start.y)}) -- (${roundNum(end.x)}, ${roundNum(end.y)});\n`;
                        }
                    }
                });
                
                // Draw lines
                parsedElements.lines.forEach(line => {
                    if (line.coords) {
                        // Line: ax + by + c = 0
                        // Find intersection with bounding box
                        const a = line.coords.a;
                        const b = line.coords.b;
                        const c = line.coords.c;
                        
                        let pts = [];
                        // Intersection with x = xmin and x = xmax
                        if (Math.abs(b) > 0.001) {
                            const y1 = (-a * xmin - c) / b;
                            const y2 = (-a * xmax - c) / b;
                            if (y1 >= ymin && y1 <= ymax) pts.push({x: xmin, y: y1});
                            if (y2 >= ymin && y2 <= ymax) pts.push({x: xmax, y: y2});
                        }
                        // Intersection with y = ymin and y = ymax
                        if (Math.abs(a) > 0.001) {
                            const x1 = (-b * ymin - c) / a;
                            const x2 = (-b * ymax - c) / a;
                            if (x1 >= xmin && x1 <= xmax) pts.push({x: x1, y: ymin});
                            if (x2 >= xmin && x2 <= xmax) pts.push({x: x2, y: ymax});
                        }
                        
                        if (pts.length >= 2) {
                            const lineColor = getTikZColor(line.color);
                            code += `\\draw[${line.lineStyle}, ${lineColor}] (${roundNum(pts[0].x)}, ${roundNum(pts[0].y)}) -- (${roundNum(pts[1].x)}, ${roundNum(pts[1].y)});\n`;
                        }
                    }
                });
                
                // Draw rays
                parsedElements.rays.forEach(ray => {
                    if (ray.startLabel && ray.throughLabel) {
                        const start = parsedElements.points[ray.startLabel];
                        const through = parsedElements.points[ray.throughLabel];
                        if (start && through) {
                            // Calculate ray direction
                            const dx = through.x - start.x;
                            const dy = through.y - start.y;
                            
                            // Use xmin/xmax/ymin/ymax (already set to clip range if enabled)
                            let maxX = xmax, maxY = ymax, minX = xmin, minY = ymin;
                            
                            // Find intersection with bounding box
                            let endX = start.x, endY = start.y;
                            let tMax = 1000; // maximum extension
                            
                            if (Math.abs(dx) > 0.0001) {
                                const t1 = (maxX - start.x) / dx;
                                const t2 = (minX - start.x) / dx;
                                if (t1 > 0) tMax = Math.min(tMax, t1);
                                if (t2 > 0) tMax = Math.min(tMax, t2);
                            }
                            if (Math.abs(dy) > 0.0001) {
                                const t1 = (maxY - start.y) / dy;
                                const t2 = (minY - start.y) / dy;
                                if (t1 > 0) tMax = Math.min(tMax, t1);
                                if (t2 > 0) tMax = Math.min(tMax, t2);
                            }
                            
                            // Apply a small margin to stay inside the boundary
                            tMax = Math.max(0.1, tMax - 0.1);
                            endX = start.x + dx * tMax;
                            endY = start.y + dy * tMax;
                            
                            const rayColor = getTikZColor(ray.color);
                            code += `\\draw[${ray.lineStyle}, ${rayColor}] (${roundNum(start.x)}, ${roundNum(start.y)}) -- (${roundNum(endX)}, ${roundNum(endY)});\n`;
                        }
                    }
                });
                
                // Draw vectors
                parsedElements.vectors.forEach(vec => {
                    if (vec.startExp) {
                        const start = parsedElements.points[vec.startExp];
                        if (start) {
                            const endX = start.x + vec.dx;
                            const endY = start.y + vec.dy;
                            const vecColor = getTikZColor(vec.color);
                            code += `\\draw[${vec.lineStyle}, ${vecColor}, ->, >=stealth] (${roundNum(start.x)}, ${roundNum(start.y)}) -- (${roundNum(endX)}, ${roundNum(endY)});\n`;
                        }
                    }
                });
                
                // Draw arcs
                parsedElements.arcs.forEach(arc => {
                    if (arc.matrix) {
                        // Calculate center from matrix
                        const cx = -arc.matrix.A4;
                        const cy = -arc.matrix.A5;
                        const r2 = arc.matrix.A2 + cx * cx + cy * cy;
                        const r = Math.sqrt(Math.abs(r2));
                        const arcColor = getTikZColor(arc.color);
                        
                        // Calculate start and end angles from endpoints
                        let startAngle = 0, endAngle = 360;
                        
                        if (arc.arcType === 'semicircle' && arc.endpoints.length >= 2) {
                            const p1 = parsedElements.points[arc.endpoints[0]];
                            const p2 = parsedElements.points[arc.endpoints[1]];
                            if (p1 && p2) {
                                // For semicircle, endpoints are on the diameter
                                // Calculate angles from center
                                const angle1 = Math.atan2(p1.y - cy, p1.x - cx) * 180 / Math.PI;
                                const angle2 = Math.atan2(p2.y - cy, p2.x - cx) * 180 / Math.PI;
                                // Semicircle spans 180 degrees
                                startAngle = angle1;
                                endAngle = angle2;
                            }
                        } else if (arc.arcType === 'circumcircleArc' && arc.endpoints.length >= 3) {
                            // CircumcircleArc: arc through points, endpoints[0] is start, endpoints[1] is intermediate, endpoints[2] is end
                            const p1 = parsedElements.points[arc.endpoints[0]];
                            const p3 = parsedElements.points[arc.endpoints[2]];
                            if (p1 && p3) {
                                startAngle = Math.atan2(p1.y - cy, p1.x - cx) * 180 / Math.PI;
                                endAngle = Math.atan2(p3.y - cy, p3.x - cx) * 180 / Math.PI;
                            }
                        } else if (arc.arcType === 'arc' && arc.endpoints.length >= 3) {
                            // Arc[center, start, end]
                            const centerPt = parsedElements.points[arc.endpoints[0]];
                            const startPt = parsedElements.points[arc.endpoints[1]];
                            const endPt = parsedElements.points[arc.endpoints[2]];
                            if (centerPt && startPt && endPt) {
                                // Override center from point
                                const actualCx = centerPt.x;
                                const actualCy = centerPt.y;
                                startAngle = Math.atan2(startPt.y - actualCy, startPt.x - actualCx) * 180 / Math.PI;
                                endAngle = Math.atan2(endPt.y - actualCy, endPt.x - actualCx) * 180 / Math.PI;
                                code += `% Arc ${arc.label}\n`;
                                code += `\\draw[${arc.lineStyle}, ${arcColor}] (${roundNum(startPt.x)}, ${roundNum(startPt.y)}) arc (${roundNum(startAngle)}:${roundNum(endAngle)}:${roundNum(r)});\n`;
                                return; // Skip default drawing
                            }
                        }
                        
                        // Normalize angles for TikZ (0 to 360)
                        if (startAngle < 0) startAngle += 360;
                        if (endAngle < 0) endAngle += 360;
                        
                        // Find a point on the arc to start from
                        const startX = cx + r * Math.cos(startAngle * Math.PI / 180);
                        const startY = cy + r * Math.sin(startAngle * Math.PI / 180);
                        
                        code += `% Arc ${arc.label}\n`;
                        code += `\\draw[${arc.lineStyle}, ${arcColor}] (${roundNum(startX)}, ${roundNum(startY)}) arc (${roundNum(startAngle)}:${roundNum(endAngle)}:${roundNum(r)});\n`;
                    }
                });
                
                // Draw sectors
                parsedElements.sectors.forEach(sector => {
                    if (sector.matrix) {
                        const cx = -sector.matrix.A4;
                        const cy = -sector.matrix.A5;
                        const r2 = sector.matrix.A2 + cx * cx + cy * cy;
                        const r = Math.sqrt(Math.abs(r2));
                        const sectorColor = getTikZColor(sector.color);
                        
                        let startAngle = 0, endAngle = 360;
                        
                        if (sector.arcType === 'sector' && sector.endpoints.length >= 3) {
                            const centerPt = parsedElements.points[sector.endpoints[0]];
                            const startPt = parsedElements.points[sector.endpoints[1]];
                            const endPt = parsedElements.points[sector.endpoints[2]];
                            if (centerPt && startPt && endPt) {
                                startAngle = Math.atan2(startPt.y - centerPt.y, startPt.x - centerPt.x) * 180 / Math.PI;
                                endAngle = Math.atan2(endPt.y - centerPt.y, endPt.x - centerPt.x) * 180 / Math.PI;
                            }
                        } else if (sector.arcType === 'circumcircleSector' && sector.endpoints.length >= 3) {
                            const p1 = parsedElements.points[sector.endpoints[0]];
                            const p3 = parsedElements.points[sector.endpoints[2]];
                            if (p1 && p3) {
                                startAngle = Math.atan2(p1.y - cy, p1.x - cx) * 180 / Math.PI;
                                endAngle = Math.atan2(p3.y - cy, p3.x - cx) * 180 / Math.PI;
                            }
                        }
                        
                        if (startAngle < 0) startAngle += 360;
                        if (endAngle < 0) endAngle += 360;
                        
                        code += `% Sector ${sector.label}\n`;
                        code += `\\fill[${sectorColor}, fill opacity=${sector.fillOpacity}] (${roundNum(cx)}, ${roundNum(cy)}) -- (${roundNum(cx + r * Math.cos(startAngle * Math.PI / 180))}, ${roundNum(cy + r * Math.sin(startAngle * Math.PI / 180))}) arc (${roundNum(startAngle)}:${roundNum(endAngle)}:${roundNum(r)}) -- cycle;\n`;
                        code += `\\draw[${sector.lineStyle}, ${sectorColor}] (${roundNum(cx)}, ${roundNum(cy)}) -- (${roundNum(cx + r * Math.cos(startAngle * Math.PI / 180))}, ${roundNum(cy + r * Math.sin(startAngle * Math.PI / 180))});\n`;
                        code += `\\draw[${sector.lineStyle}, ${sectorColor}] (${roundNum(cx)}, ${roundNum(cy)}) -- (${roundNum(cx + r * Math.cos(endAngle * Math.PI / 180))}, ${roundNum(cy + r * Math.sin(endAngle * Math.PI / 180))});\n`;
                        code += `\\draw[${sector.lineStyle}, ${sectorColor}] (${roundNum(cx + r * Math.cos(startAngle * Math.PI / 180))}, ${roundNum(cy + r * Math.sin(startAngle * Math.PI / 180))}) arc (${roundNum(startAngle)}:${roundNum(endAngle)}:${roundNum(r)});\n`;
                    }
                });
                
                // Draw angles
                parsedElements.angles.forEach(angle => {
                    if (angle.points.length === 3) {
                        const A = parsedElements.points[angle.points[0]];
                        const B = parsedElements.points[angle.points[1]];
                        const C = parsedElements.points[angle.points[2]];
                        if (A && B && C) {
                            const angleRad = angle.value || 0;
                            const startAngle = Math.atan2(A.y - B.y, A.x - B.x) * 180 / Math.PI;
                            const angleColor = getTikZColor(angle.color);
                            code += `\\draw[${angleColor}, fill=${angleColor}, fill opacity=0.1] (${roundNum(B.x)}, ${roundNum(B.y)}) -- ++(${startAngle}:0.3) arc (${startAngle}:${startAngle + angleRad * 180 / Math.PI}:0.3) -- cycle;\n`;
                        }
                    }
                });
                
                // Draw points
                if (includePoints) {
                    Object.values(parsedElements.points).forEach(point => {
                        // GeoGebra pointSize range: 1-9, default 5
                        // Map to reasonable TikZ radius: 1.0-2.5pt range
                        const radius = Math.max(1.0, Math.min(2.5, point.size * 0.35));
                        const pointColor = getTikZColor(point.color);
                        code += `\\fill[${pointColor}] (${roundNum(point.x)}, ${roundNum(point.y)}) circle (${roundNum(radius)}pt);\n`;
                    });
                }
                
                // Draw point labels
                if (includeLabels) {
                    Object.values(parsedElements.points).forEach(point => {
                        // Smart label positioning
                        let anchor = 'above';
                        if (point.x < 0 && point.y > 0) anchor = 'above left';
                        else if (point.x > 0 && point.y > 0) anchor = 'above right';
                        else if (point.x < 0 && point.y < 0) anchor = 'below left';
                        else if (point.x > 0 && point.y < 0) anchor = 'below right';
                        
                        const labelColor = getTikZColor(point.color);
                        code += `\\node[${anchor}, ${labelColor}] at (${roundNum(point.x)}, ${roundNum(point.y)}) {$${point.label}$};\n`;
                    });
                }
                
                code += '\\end{tikzpicture}';
                
                return code;
            }
            
            // Handle file processing
            async function processGGBFile(file) {
                try {
                    const zip = await JSZip.loadAsync(file);
                    
                    // Find geogebra.xml
                    const ggbFile = zip.file('geogebra.xml');
                    if (!ggbFile) {
                        throw new Error(t('xmlNotFound'));
                    }
                    
                    const xmlContent = await ggbFile.async('string');
                    
                    // Parse XML
                    parseGeogebraXML(xmlContent);
                    
                    // Update function list panel
                    updateFunctionList();
                    
                    // Update element info
                    const elemCount = Object.keys(parsedElements.points).length +
                        parsedElements.segments.length +
                        parsedElements.lines.length +
                        parsedElements.rays.length +
                        parsedElements.vectors.length +
                        parsedElements.circles.length +
                        parsedElements.ellipses.length +
                        parsedElements.hyperbolas.length +
                        parsedElements.parabolas.length +
                        parsedElements.arcs.length +
                        parsedElements.sectors.length +
                        parsedElements.polygons.length +
                        parsedElements.functions.length +
                        parsedElements.angles.length;
                    
                    elementInfo.style.display = 'block';
                    elementList.innerHTML = '';
                    
                    const addTag = (text, color = '#3498db') => {
                        const tag = document.createElement('span');
                        tag.className = 'element-tag';
                        tag.style.background = color;
                        tag.textContent = text;
                        elementList.appendChild(tag);
                    };
                    
                    if (Object.keys(parsedElements.points).length > 0) addTag(`${t('point')} √ó${Object.keys(parsedElements.points).length}`, '#e74c3c');
                    if (parsedElements.segments.length > 0) addTag(`${t('segment')} √ó${parsedElements.segments.length}`, '#3498db');
                    if (parsedElements.lines.length > 0) addTag(`${t('line')} √ó${parsedElements.lines.length}`, '#2ecc71');
                    if (parsedElements.rays.length > 0) addTag(`${t('ray')} √ó${parsedElements.rays.length}`, '#f39c12');
                    if (parsedElements.vectors.length > 0) addTag(`${t('vector')} √ó${parsedElements.vectors.length}`, '#9b59b6');
                    if (parsedElements.circles.length > 0) addTag(`${t('circle')} √ó${parsedElements.circles.length}`, '#1abc9c');
                    if (parsedElements.ellipses.length > 0) addTag(`${t('ellipse')} √ó${parsedElements.ellipses.length}`, '#e67e22');
                    if (parsedElements.hyperbolas.length > 0) addTag(`${t('hyperbola')} √ó${parsedElements.hyperbolas.length}`, '#c0392b');
                    if (parsedElements.parabolas.length > 0) addTag(`${t('parabola')} √ó${parsedElements.parabolas.length}`, '#8e44ad');
                    if (parsedElements.arcs.length > 0) addTag(`${t('arc')} √ó${parsedElements.arcs.length}`, '#16a085');
                    if (parsedElements.sectors.length > 0) addTag(`${t('sector')} √ó${parsedElements.sectors.length}`, '#27ae60');
                    if (parsedElements.polygons.length > 0) addTag(`${t('polygon')} √ó${parsedElements.polygons.length}`, '#2980b9');
                    if (parsedElements.functions.length > 0) addTag(`${t('function')} √ó${parsedElements.functions.length}`, '#006758');
                    if (parsedElements.angles.length > 0) addTag(`${t('angle')} √ó${parsedElements.angles.length}`, '#d35400');
                    
                    // Generate TikZ code
                    const tikzCode = generateTikZCode();
                    outputCode.value = tikzCode;
                    updateViewCodeButton();
                    
                    showNotification(`${t('convertSuccess')} ${elemCount} ${t('elements')}`);
                    
                } catch (error) {
                    console.error('Error processing GGB file:', error);
                    showNotification(t('processError') + error.message, true);
                }
            }
            
            // Drag and drop handlers
            dropZone.addEventListener('click', () => fileInput.click());
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.endsWith('.ggb')) {
                        fileName.textContent = 'üìÑ ' + file.name;
                        fileName.style.display = 'block';
                        processGGBFile(file);
                    } else {
                        showNotification(t('invalidFormat'), true);
                    }
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (file.name.endsWith('.ggb')) {
                        fileName.textContent = 'üìÑ ' + file.name;
                        fileName.style.display = 'block';
                        processGGBFile(file);
                    } else {
                        showNotification(t('invalidFormat'), true);
                    }
                }
            });
            
            // Copy button
            copyBtn.addEventListener('click', () => {
                if (outputCode.value) {
                    navigator.clipboard.writeText(outputCode.value).then(() => {
                        showNotification(t('copySuccess'));
                    }).catch(err => {
                        showNotification(t('copyFailed') + err, true);
                    });
                } else {
                    showNotification(t('noContent'), true);
                }
            });
            
            // View code button
            viewCodeBtn.addEventListener('click', openCodeViewer);
            
            // Code viewer modal events
            codeViewerClose.addEventListener('click', closeCodeViewer);
            codeViewerModal.addEventListener('click', (e) => {
                if (e.target === codeViewerModal) {
                    closeCodeViewer();
                }
            });
            
            // Code viewer copy button
            codeViewerCopyBtn.addEventListener('click', () => {
                if (outputCode.value) {
                    navigator.clipboard.writeText(outputCode.value).then(() => {
                        showNotification(t('copySuccess'));
                    }).catch(err => {
                        showNotification(t('copyFailed') + err, true);
                    });
                }
            });
            
            // Clear button
            clearBtn.addEventListener('click', () => {
                outputCode.value = '';
                fileName.style.display = 'none';
                elementInfo.style.display = 'none';
                fileInput.value = '';
                viewCodeBtn.style.display = 'none';
                parsedElements = {
                    points: {},
                    segments: [],
                    lines: [],
                    rays: [],
                    vectors: [],
                    circles: [],
                    ellipses: [],
                    parabolas: [],
                    hyperbolas: [],
                    arcs: [],
                    sectors: [],
                    polygons: [],
                    functions: [],
                    angles: [],
                    texts: []
                };
                functionRanges = {};
                updateFunctionList();
                showNotification(t('cleared'));
            });
            
            // Options change handlers - regenerate code
            ['includePoints', 'includeLabels', 'roundCoordinates', 'blackAndWhite', 'includeAxes', 'includeGrid', 'enableClipRange', 'clipXmin', 'clipXmax', 'clipYmin', 'clipYmax'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', () => {
                        if (Object.keys(parsedElements.points).length > 0 || parsedElements.segments.length > 0) {
                            outputCode.value = generateTikZCode();
                            updateViewCodeButton();
                        }
                    });
                }
            });
        });
    </script>
</body>
</html>
